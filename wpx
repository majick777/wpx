#!/bin/bash

# ================================ #
# === WPX - WP CLI Multiplied! === #
# ================================ #
# ========= Version 1.0.3 ======== #
# ================================ #
#
# "You'll see your commands multiplied, if you continually decide, 
# 	to faithfully pursue, the policy of root."
#
# Love this tool? Become a WP Medic Patron: https://patreon.com/wpmedic
#
# WPX Home: http://wpmedic.tech/wpx/
# WPX GitHub: https://github.com/majick777/wpx/
#
# WP CLI Home: http://wp-cli.org/
# WP CLI Command Reference: https://developer.wordpress.org/cli/commands/
#
# For Installation and Usage Notes please see wpx.md


# -----------------
# Development TODOs
# -----------------
#
# - selective theme listing (like plugin listing)
# - add updatelist command (list all core/plugins/themes updates for site)
#
# * allow for use of @alias in combination with site slug
# -- ref: https://make.wordpress.org/cli/handbook/config/
# ** lockcore, unlockcore
# -> updatecore, installcore (->reinstallcore)
# -> checkowners, fixowners
#
# * allow for SSH site path syncing
# -> installcore (->reinstallcore)
# -> all sync commands
#
# ? backup old plugin to restore on install/update failure ?
# ? plugin and theme version parameters ?
# ? add plugin and theme rollback functions ?
# ? handle alternate zip and http:// sources ? 
#
# ? define SUCCESS values for:
# -- verifycore, installcore, updatecore
# -- updateallplugins
#
# + add more WPX command examples to readme file


# === Setup ===
# - Output Valid Command List
# - Colour Functions
# - Check Action Result
# - Create Command Combo Array
# - Check for Element in Array
# === YAML Helpers ===
# - Fix YAML File
# - Parse YAML File
# - Load YAML File
# === Core Commands ===
# - Debug Info 
# - Check Version
# - Verify Core
# - Update Core
# - Install Core
# - Reinstall Core
# - Lock Core
# - Unlock Core
# - Check Core Lock
# - Check File Owners/Groups
# - Fix File Owners/Groups
# === Plugin Commands ===

# === Sync Commands ===
# - Sync Core
# - Sync Plugin
# - Sync and Activate Plugin
# - Sync Theme
# - Sync and Activate Theme
# - Sync Must Use Plugin
# - Sync Dropin
# === Language Commands ===
# - Install Language
# - Uninstall Language
# - Activate Language
# - Update Language
# === Command Line Arguments ===
# === Loop Site Commands ===



# ------------- #
# === SETUP === #
# ------------- #

# debug command output
set +x

# declare some globals
CWD=$(pwd)
RESULT=""
INARRAY=""
REINSTALL=""
DEBUG="false"
FOUND=""
DONE=""

# ------------------------- #
# Output Valid Command List #
# ------------------------- #
function validcommands {
	red "Valid Commands"; echo ":"
	printf "["; yellow "CORE"; echo "] checkversion, verifycore, installcore, reinstallcore, updatecore, lockcore, unlockcore, checklock, checkowners, fixowners"
	printf "["; yellow "PLUGIN"; echo "] listplugins, activateplugin, deactivateplugin, installplugin, installactivateplugin, reinstallplugin, updateplugin, updateallplugins, deleteplugin"
	printf "["; yellow "THEME"; echo "] listthemes, activatetheme, installtheme, installactivatetheme, reinstalltheme, updatetheme"
	printf "["; yellow "SYNC"; echo "] syncplugin, syncactivateplugin, syncmuplugin, synctheme, syncactivatetheme, syncmuplugin, syncdropin"
	printf "["; yellow "LANGUAGE"; echo "] installlanguage, activatelanguage, updatelanguage, uninstalllanguage"
}

# ---------------- #
# Colour Functions #
# ---------------- #
black() { printf "$(tput setaf 0)$*$(tput setaf 9)"; }
red() { printf "$(tput setaf 1)$*$(tput setaf 9)"; }
green() { printf "$(tput setaf 2)$*$(tput setaf 9)"; }
yellow() { printf "$(tput setaf 3)$*$(tput setaf 9)"; }
blue() { printf "$(tput setaf 4)$*$(tput setaf 9)"; }
magenta() { printf "$(tput setaf 5)$*$(tput setaf 9)"; }
cyan() { printf "$(tput setaf 6)$*$(tput setaf 9)"; }
white() { printf "$(tput setaf 7)$*$(tput setaf 9)"; }

# ------------------- #
# Check Action Result #
# ------------------- #
function checkresult {

	local OUTPUT; local SUCCESS; local TYPE
	OUTPUT=$1; SUCCESS=$2; TYPE=$3
	
	# - set already done check strings -
	# TODO: maybe set more "already done" strings ?
	if [ "$TYPE" == 'install' ]; then ALREADY="already installed"; fi
	if [ "$TYPE" == 'activate' ]; then ALREADY="already activated"; fi
	
	# TODO: if [[ "$OUTPUT" == *"Error"* ]]; then
	
		# if [[ "$OUTPUT" == *"PHP Parse Error"* ]]; then
		#	echo "";		
		# fi

		# if [[ "$OUTPUT" == *"PHP Warning"* ]]; then
		#	echo "";		
		# fi

		if [[ "$OUTPUT" == *"Error establishing a database connection"* ]]; then

			# - check mysql service status -
			STATUS=$(netstat -vulntp | grep -i mysql)
			if [ -z "$STATUS" ]; then
				yellow "**"; echo " Restarting MySQL Server and retrying..."
				RESTART=$(service mysql restart)
				echo "$RESTART"			
			fi			
					
			RESULT="failed"
			return
		fi
		
	# fi;
	
	# if [ -z "$SUCCESS ]"; then
		if [[ "$OUTPUT" == *"$SUCCESS"* ]]; then 
			RESULT="success"
		else 
			if [[ "$OUTPUT" == *"$ALREADY"* ]]; then 
				RESULT="success"
			else 
				RESULT="failed"
			fi
		fi
	# fi
	
}

# -------------------------- #
# Create Command Combo Array #
# -------------------------- #
function createarray {

	ARRAY=()	
	ARRAY[0]="$1""$2"
	ARRAY[1]="$1""$2""s"
	ARRAY[2]="$1""_""$2"
	ARRAY[3]="$1""_""$2""s"
	ARRAY[4]="$1""-""$2"
	ARRAY[5]="$1""-""$2""s"
	ARRAY[6]="$2""$1"
	ARRAY[7]="$2""s""$2"
	ARRAY[8]="$2""_""$1"
	ARRAY[9]="$2""s_""$1"
	ARRAY[10]="$2""-""$1"
	ARRAY[11]="$2""s-""$2"
	
	if [ -n "$3" ] && [ -n "$4" ]; then
		ARRAY[12]="$3""$4"
		ARRAY[13]="$3""$4""s"
		ARRAY[14]="$3""_""$4"
		ARRAY[15]="$3""_""$4""s"
		ARRAY[16]="$3""-""$4"
		ARRAY[17]="$3""-""$4""s"
		ARRAY[18]="$4""$3"
		ARRAY[19]="$4""s""$3"
		ARRAY[20]="$4""_""$3"
		ARRAY[21]="$4""s_""$4"
		ARRAY[22]="$4""-""$3"
		ARRAY[23]="$4""s-""$3"
	fi
}

# -------------------------- #
# Check for Element in Array # 
# -------------------------- #
function checkarray {
	local MATCH; MATCH=$1; INARRAY=""
	for ELEMENT in "${ARRAY[@]}"; do
		if [[ "$ELEMENT" == "$MATCH" ]]; then 
			INARRAY="1"; echo "1"; return
		fi
	done
}

# note output elements and matches but may break things
function checkarraydebug {
	local MATCH; MATCH=$1; INARRAY=""
	for ELEMENT in "${ARRAY[@]}"; do
		white "$ELEMENT"" - ""$MATCH"
		if [[ "$ELEMENT" == "$MATCH" ]]; then 
			white " (MATCHED)"
			INARRAY="1"; return
		fi
		echo ""
	done
}


# -------------------- #
# === YAML HELPERS === #
# -------------------- #

# ------------- #
# Fix YAML File #
# ------------- #
function fix_yaml {
	
	LINES=$(cat "$1")
	while IFS= read -r -a LINE || [ -n "$LINE" ]; do
		TESTLINE=$(echo "$LINE" | awk '{$1=$1;print}')
		CHAR="${TESTLINE:0:1}"
		if [ ! "$CHAR" == "#" ]; then
			if [ "$CHAR" == "@" ] || [ "$CHAR" == "~" ]; then
				echo "alias_""${TESTLINE:1}"
			else
				CHARS="${TESTLINE:0:3}"
				if [ "$CHARS" == "- @" ]; then
					echo " - alias_""${TESTLINE:3}"
				else
					echo "$LINE"
				fi
			fi
		fi
	done <<< "$LINES"
}

# --------------- #
# Parse YAML File #
# --------------- #
# ref: https://stackoverflow.com/a/51789677/5240159
# source: https://github.com/mrbaseman/parse_yaml.git
function parse_yaml {

   local prefix=$2
   local separator=${3:-_}
   local s='[[:space:]]*' w='[a-zA-Z0-9_]*' fs=${fs:-$(echo @|tr @ '\034')} i=${i:-  }
     
   cat $1 | \
   awk -F$fs "{multi=0; 
       if(match(\$0,/$s\|$s\$/)){multi=1; sub(/$s\|$s\$/,\"\");}
       if(match(\$0,/$s>$s\$/)){multi=2; sub(/$s>$s\$/,\"\");}
       while(multi>0){
           str=\$0; gsub(/^$s/,\"\", str);
           indent=index(\$0,str);
           indentstr=substr(\$0, 0, indent-1) \"$i\";
           obuf=\$0;
           getline;
           while(index(\$0,indentstr)){
               obuf=obuf substr(\$0, length(indentstr)+1);
               if (multi==1){obuf=obuf \"\\\\n\";}
               if (multi==2){
                   if(match(\$0,/^$s\$/))
                       obuf=obuf \"\\\\n\";
                       else obuf=obuf \" \";
               }
               getline;
           }
           sub(/$s\$/,\"\",obuf);
           multi=0;
           if(match(\$0,/$s\|$s\$/)){multi=1; sub(/$s\|$s\$/,\"\");}
           if(match(\$0,/$s>$s\$/)){multi=2; sub(/$s>$s\$/,\"\");}
       }
   print}" | \
   sed  -e "s|^\($s\)?|\1-|" \
       -ne "s|^$s#.*||;s|$s#[^\"']*$||;s|^\([^\"'#]*\)#.*|\1|;t1;t;:1;s|^$s\$||;t2;p;:2;d" | \
   sed -ne "s|,$s\]$s\$|]|" \
        -e ":1;s|^\($s\)\($w\)$s:$s\(&$w\)\?$s\[$s\(.*\)$s,$s\(.*\)$s\]|\1\2: \3[\4]\n\1$i- \5|;t1" \
        -e "s|^\($s\)\($w\)$s:$s\(&$w\)\?$s\[$s\(.*\)$s\]|\1\2: \3\n\1$i- \4|;" \
        -e ":2;s|^\($s\)-$s\[$s\(.*\)$s,$s\(.*\)$s\]|\1- [\2]\n\1$i- \3|;t2" \
        -e "s|^\($s\)-$s\[$s\(.*\)$s\]|\1-\n\1$i- \2|;p" | \
   sed -ne "s|,$s}$s\$|}|" \
        -e ":1;s|^\($s\)-$s{$s\(.*\)$s,$s\($w\)$s:$s\(.*\)$s}|\1- {\2}\n\1$i\3: \4|;t1" \
        -e "s|^\($s\)-$s{$s\(.*\)$s}|\1-\n\1$i\2|;" \
        -e ":2;s|^\($s\)\($w\)$s:$s\(&$w\)\?$s{$s\(.*\)$s,$s\($w\)$s:$s\(.*\)$s}|\1\2: \3 {\4}\n\1$i\5: \6|;t2" \
        -e "s|^\($s\)\($w\)$s:$s\(&$w\)\?$s{$s\(.*\)$s}|\1\2: \3\n\1$i\4|;p" | \
   sed  -e "s|^\($s\)\($w\)$s:$s\(&$w\)\(.*\)|\1\2:\4\n\3|" \
        -e "s|^\($s\)-$s\(&$w\)\(.*\)|\1- \3\n\2|" | \
   sed -ne "s|^\($s\):|\1|" \
        -e "s|^\($s\)\(---\)\($s\)||" \
        -e "s|^\($s\)\(\.\.\.\)\($s\)||" \
        -e "s|^\($s\)-$s[\"']\(.*\)[\"']$s\$|\1$fs$fs\2|p;t" \
        -e "s|^\($s\)\($w\)$s:$s[\"']\(.*\)[\"']$s\$|\1$fs\2$fs\3|p;t" \
        -e "s|^\($s\)-$s\(.*\)$s\$|\1$fs$fs\2|" \
        -e "s|^\($s\)\($w\)$s:$s[\"']\?\(.*\)$s\$|\1$fs\2$fs\3|" \
        -e "s|^\($s\)[\"']\?\([^&][^$fs]\+\)[\"']$s\$|\1$fs$fs$fs\2|" \
        -e "s|^\($s\)[\"']\?\([^&][^$fs]\+\)$s\$|\1$fs$fs$fs\2|" \
        -e "s|$s\$||p" | \
   awk -F$fs "{
      gsub(/\t/,\"        \",\$1);
      if(NF>3){if(value!=\"\"){value = value \" \";}value = value  \$4;}
      else {
        if(match(\$1,/^\&/)){anchor[substr(\$1,2)]=full_vn;getline};
        indent = length(\$1)/length(\"$i\");
        vname[indent] = \$2;
        value= \$3;
        for (i in vname) {if (i > indent) {delete vname[i]; idx[i]=0}}
        if(length(\$2)== 0){  vname[indent]= ++idx[indent] };
        vn=\"\"; for (i=0; i<indent; i++) { vn=(vn)(vname[i])(\"$separator\")}
        vn=\"$prefix\" vn;
        full_vn=vn vname[indent];
        if(vn==\"$prefix\")vn=\"$prefix$separator\";
        if(vn==\"_\")vn=\"__\";
      }
      assignment[full_vn]=value;
      if(!match(assignment[vn], full_vn))assignment[vn]=assignment[vn] \" \" full_vn;
      if(match(value,/^\*/)){
         ref=anchor[substr(value,2)];
         for(val in assignment){
            if(index(val, ref)==1){
               tmpval=assignment[val];
               sub(ref,full_vn,val);
               if(match(val,\"$separator\$\")){
                  gsub(ref,full_vn,tmpval);
               } else if (length(tmpval) > 0) {
                  printf(\"%s=\\\"%s\\\"\n\", val, tmpval);
               }
               assignment[val]=tmpval;
            }
         }
      } else if (length(value) > 0) {
         printf(\"%s=\\\"%s\\\"\n\", full_vn, value);
      }
   }END{
      asorti(assignment,sorted);
      for(val in sorted){
         if(match(sorted[val],\"$separator\$\"))
            printf(\"%s=\\\"%s\\\"\n\", sorted[val], assignment[sorted[val]]);
      }
   }"
}

# -------------- #
# Load YAML File #
# -------------- #
function load_yaml {

	# - fix @ symbols (for parsing site aliases) -
	FIXED=$(fix_yaml "$YMLPATH")
	if [ "$DEBUG" == "true" ]; then white "$YMLPATH"; echo " Contents:"; echo "$FIXED"; fi
		
	# - parse the fixed YAML data -
	PARSED=$(parse_yaml <<< "$FIXED")
	if [ "$DEBUG" == "true" ]; then echo ""; echo "Parsed Contents: "; echo "$PARSED"; fi
	
	# - load parsed data as variables -
	eval "$PARSED"
	
	# TODO: load inherited and reload YAML ?
	if [ -n "$___inherit" ]; then
		# if [ "$DEBUG" == "true" ]; then echo "$___inherit"; fi
		echo "Inherit TML Config File: ""$___inherit"
	fi	
}


# --------------------- #
# === CORE COMMANDS === #
# --------------------- #

# ---------- #
# Debug Info #
# ---------- #
function wpdebug {

	OUTPUT=$("$WP" --debug --info)
	echo "$OUTPUT"
}

# ------------- #
# Check Version #
# ------------- #
function checkversion {
	
	# - define success -
	SUCCESS="WordPress version"

	# - get core version -
	# local VERSIONPATH; local VERSION
	# VERSIONPATH="$SITEPATH""wp-includes/version.php"
	# VERSION=$(grep -m 1 "wp_version = " "$VERSIONPATH" | cut -d \' -f2)
	COMMAND="sudo -u ""$SITEUSER"" ""$WP"" core version --extra"
	OUTPUT=$($COMMAND)

	# - maybe try again -
	checkresult "$OUTPUT" "$SUCCESS"
	if [ "$RESULT" == "failed" ]; then OUTPUT=$($COMMAND); fi

	if [[ "$OUTPUT" == *"WordPress version"* ]]; then
	
		# - get version data from output -
		VERSION=$(grep "WordPress version:" <<< "$OUTPUT" | awk '{print $3}')
		DBVERSION=$(grep "Database revision:" <<< "$OUTPUT" | awk '{print $3}')
		MCEVERSION=$(grep "TinyMCE version:" <<< "$OUTPUT" | awk '{print $3}')
		LOCALE=$(grep "Package language:" <<< "$OUTPUT" | awk '{print $3}')

		# - output coloured version info -
		white "Site: "; green "$SITENAME"; echo ""
		white "Path: "; cyan "$SITEPATH"; echo ""
		white "WordPress version: "; yellow "$VERSION"; echo ""
		white "Database revision: "; yellow "$DBVERSION"; echo ""
		white "TinyMCE version: "; yellow "$MCEVERSION"; echo ""
		white "Package language: "; yellow "$LOCALE"; echo ""
		
	else

		# - output error message -
		red "Error."; echo " Could not detect WordPress version."

	fi

	# - check for core updates -
	echo "Checking for core updates..."
	OUTPUT=$(sudo -u ""$SITEUSER"" ""$WP"" core check-update --format=csv | tail -n +2)

	# - output core updates available -
	while IFS= read -r -a LINE; do
		if [[ "$LINE" == *","* ]]; then
			VERSION=$(awk -F',' '{print $1}' <<< "$LINE")
			TYPE=$(awk -F',' '{print $2}' <<< "$LINE")
			white "Update to "; yellow "$VERSION"; white " ("; yellow "$TYPE"; white ") available."; echo ""
		fi
	done <<< "$OUTPUT"

}

# ----------- #
# Verify Core #
# ----------- #
function verifycore {

	# TODO: define SUCCESS for verify checksums?
	# SUCCESS=""

	# - get core version -
	# local VERSIONPATH; local VERSION
	# VERSIONPATH="$SITEPATH""wp-includes/version.php"
	# VERSION=$(grep -m 1 "wp_version = " "$VERSIONPATH" | cut -d \' -f2)
	VERSION=$("$WP" core version --extra | grep "WordPress version:" | cut -d " " -f3)

	# - output verify checksum message -
	yellow "***"; printf " Verifying core checksums for "; green "$SITENAME"; printf " (WP "; yellow "$VERSION"; echo ")"
	
	# - set command and execute -
	COMMAND="sudo -u ""$SITEUSER"" ""$WP"" core verify-checksums --version=""$VERSION"" --skip-plugins"
	OUTPUT=$($COMMAND)
	
	# - check result and maybe try again -
	checkresult "$OUTPUT"
	if [ "$RESULT" == "failed" ]; then OUTPUT=$($COMMAND); fi

	echo "$OUTPUT"
}

# ----------- #
# Update Core #
# ----------- #
function updatecore {
	
	local VERSION=$1

	# TODO: define SUCCESS for core update ?
	SUCCESS=""
	
	# - maybe unlock core -
	if [ "$SITELOCKING" == "true" ]; then unlockcore; fi
	
	# - attempt core update -
	if [ -n "$VERSION" ]; then
		if [ "$VERSION" == "minor" ] || [ "$VERSION" == "patch" ]; then
			# - update to minor version
			if [ "$VERSION" == "patch" ]; then VERSION="minor"; fi
			yellow "***"; printf " Updating core on "; green "$SITENAME"; printf " ("; yellow "$VERSION"; echo " only)..."
			COMMAND="sudo -u ""$SITEUSER"" ""$WP"" core update --skip-plugins --""$VERSION"
		else
			# - force update to specific version -
			yellow "***"; printf " Updating core on "; green "$SITENAME"; printf " to Version "; yellow "$VERSION"; echo "..."
			COMMAND="sudo -u ""$SITEUSER"" ""$WP"" core update --skip-plugins --version=""$VERSION"" --force"
		fi
	else
		# - update to latest version -
		yellow "***"; printf " Updating core on "; green "$SITENAME"; echo "..."
		COMMAND="sudo -u ""$SITEUSER"" ""$WP"" core update --skip-plugins"	
	fi
	
	# - execute command -
	OUTPUT=$($COMMAND)
	
	# - maybe try again -
	checkresult "$OUTPUT" "$SUCCESS"
	if [ "$RESULT" == "failed" ]; then OUTPUT=$($COMMAND); fi
	
	echo "$OUTPUT"
	
	# - maybe relock core -
	if [ "$SITELOCKING" == "true" ]; then lockcore; fi
}

# ------------ #
# Install Core #
# ------------ #
function installcore {

	local VERSION; local LOCALE; local TEMPCOREPATH
	
	# - set values -
	VERSION=$1; LOCALE=$2; TEMPCOREPATH="$SITEPATH""core-temp/"

	# - maybe unlock core -
	if [ "$SITELOCKING" == "true" ]; then unlockcore; fi

	# - clear new core temp directory -
	sudo -u "$SITEUSER" rm -rf "$TEMPCOREPATH"
	sudo -u "$SITEUSER" mkdir "$TEMPCOREPATH"
	
	# - download core -
	if [ -z "$LOCALE" ]; then
		yellow "***"; printf " Installing Core (Version: "; yellow "$VERSION"; printf ") for "; green "$SITENAME"; echo "..."
		COMMAND="sudo -u ""$SITEUSER"" ""$WP"" core download --version=""$VERSION"" --path=""$TEMPCOREPATH"
	else 
		yellow "***"; printf " Installing Core (Version: "; yellow "$VERSION"; printf ", Locale: "; yellow "$LOCALE"; printf ") for "; green "$SITENAME"; echo "..."
		COMMAND="sudo -u ""$SITEUSER"" ""$WP"" core download --version=""$VERSION"" --locale=""$LOCALE"" --path=""$TEMPCOREPATH"
	fi
	
	# - execute command -
	OUTPUT=$($COMMAND)
	
	# TODO: define SUCCESS (for reattempt) ?
	# SUCCESS=""
	checkresult "$OUTPUT" "$SUCCESS"
	
	# - maybe retry core download -
	# if [ "$RESULT" == "failed" ]; then OUTPUT=$($COMMAND); fi

	echo "$OUTPUT"

	if [ "$RESULT" == "success" ]; then

		# - output core syncing message -
		yellow "***"; printf " Syncing Downloaded Core to "; cyan "$SITEPATH"; echo "..."
	
		# - remove wp-content directory from temporary core to prevent overwriting -
		if [ "$REINSTALL" == "true" ]; then
			sudo -u "$SITEUSER" rm -rf "$TEMPCOREPATH"/wp-content
		fi
	
		# - sync from temp core dir to core dir -
		# TODO: maybe use with --backup option?
		# TODO: allow for SSH site path destination here
		sudo -u "$SITEUSER" rsync --delay-updates --remove-source-files -av "$TEMPCOREPATH" "$SITEPATH"
		
		# - cleanup temp core directory -
		sudo -u "$SITEUSER" rm -rf "$TEMPCOREPATH"
	fi
	
	# - maybe relock core -
	if [ "$SITELOCKING" == "true" ]; then lockcore; fi
}

# -------------- #
# Reinstall Core #
# -------------- #
function reinstallcore {
	
	local LOCALE
	
	# - get current version -
	# local VERSION; local VERSIONPATH;
	# VERSIONPATH="$SITEPATH""wp-includes/version.php"
	# VERSION=$(grep -m 1 "wp_version = " "$VERSIONPATH" | cut -d \' -f2)
	VERSION=$("$WP" core version --extra | grep "WordPress version:" | cut -d " " -f3)
	
	# - get active language locale -
	# note: older versions of WP CLI use 'wp core language list' (so update!)
	LOCALE=$(sudo -u "$SITEUSER" "$WP" language core list --status=active | grep "active" | cut -f1)

	# - output reinstalling core message -
	yellow "***"; printf " Reinstalling Core (Version: "; yellow "$VERSION"; printf ", Locale: "; yellow "$LOCALE"; printf ") for "; green "$SITENAME"; echo "..."

	# - set reinstalling flag -
	REINSTALL="true"

	# - reinstall existing version / locale -
	installcore "$VERSION" "$LOCALE"
}

# --------- #
# Lock Core #
# --------- #
function lockcore {

	local INCLUDES; local ADMIN;
	
	# - set paths -
	INCLUDES="$SITEPATH""/wp-includes"
	ADMIN="$SITEPATH""/wp-admin"
	
	# TODO: lock core for site aliases
	if [ -n "$ALIAS" ]; then
		red "Error."; printf " Cannot lock core for site aliases (yet.)"; echo ""; return
	fi
	
	# - output locking message -
	yellow "**"; printf " Locking "; white "$SITEPATH"; echo "..."
	
	# - lock core base files -
	# note: skips license.txt and readme.html
	BASEFILES=(".htaccess" "index.php" "wp-activate.php" "wp-blog-header.php" "wp-comments-post.php" "wp-config.php" "wp-config-sample.php" "wp-cron.php" "wp-links-opml.php" "wp-login.php" "wp-mail.php" "wp-settings.php" "wp-signup.php" "wp-trackback.php" "xmlrpc.php")
	for BASEFILE in "${BASEFILES[@]}"; do
		FILEPATH="$SITEPATH""/""$BASEFILE"
		if [ -e "$FILEPATH" ]; then
		 	sudo -u root chattr +i "$FILEPATH"
		else
			red "Error!"; white " $BASEFILE"; echo " not found!"
	 	fi
	done
	
	# - lock wp-includes recursively - 
	if [ -d "$INCLUDES" ]; then
		sudo -u root chattr -R +i "$INCLUDES"
	else 
		red "Error!"; echo " /wp-includes/ directory not found!"
	fi
	
	# - lock wp-admin recursively - 
	if [ -d "$ADMIN" ]; then
		sudo -u root chattr -R +i "$ADMIN"
		// 1.0.3: attempt to preserve wp-admin error log writeability
		if [ -f "$ADMIN""php_errors.log" ]; then
			sudo -u root chattr -i "$ADMIN""php_errors.log"
		fi
	else
		red "Error!"; echo " /wp-admin/ directory not found!"
	fi
}

# ----------- #
# Unlock Core #
# ----------- #
function unlockcore {

	local INCLUDES; local ADMIN
	
	# - set paths -
	INCLUDES="$SITEPATH""/wp-includes"
	ADMIN="$SITEPATH""/wp-admin"

	# TODO: unlock core for site aliases
	if [ -n "$ALIAS" ]; then
		red "Error."; printf " Cannot unlock core for site aliases (yet.)"; echo ""; return
	fi
	
	# - output unlock message -
	yellow "**"; printf " Unlocking "; white "$SITEPATH"; echo "..."
	
	# - unlock core base files -
	# note: skip license.txt and readme.html
	BASEFILES=(".htaccess" "index.php" "wp-activate.php" "wp-blog-header.php" "wp-comments-post.php" "wp-config.php" "wp-config-sample.php" "wp-cron.php" "wp-links-opml.php" "wp-login.php" "wp-mail.php" "wp-settings.php" "wp-signup.php" "wp-trackback.php" "xmlrpc.php")
	for BASEFILE in "${BASEFILES[@]}"; do
		FILEPATH="$SITEPATH""/""$BASEFILE"
		if [ -e "$FILEPATH" ]; then
		 	sudo -u root chattr -i "$FILEPATH"
		else
			red "Error!"; white " ""$BASEFILE"; echo " not found!"
		fi
	done
	
	# - unlock wp-includes recursively -
	if [ -d "$INCLUDES" ]; then
		sudo -u root chattr -R -i "$INCLUDES"
	else
		red "Error!"; echo " /wp-includes/ directory not found!"
	fi
	
	# - unlock wp-admin recursively -
	if [ -d "$ADMIN" ]; then
		sudo -u root chattr -R -i "$ADMIN"
	else
		red "Error!"; echo " /wp-admin/ directory not found!"
	fi
}

# --------------- #
# Check Core Lock #
# --------------- #
function checkcorelock {
	
	local INCLUDES; local ADMIN
	
	INCLUDES="$SITEPATH""/wp-includes"
	ADMIN="$SITEPATH""/wp-admin"
	# local LOCKFILE=$SITENAME".lok"
	
	# TODO: check core lock for site aliases
	if [ -n "$ALIAS" ]; then
		red "Error."; printf " Cannot check core lock for site aliases (yet.)"; echo ""; return
	fi
	
	# - output lock check message -
	yellow "**"; printf " Checking Core file locks for "; green "$SITENAME"; echo "..."
	
	# - check lock for core base files -
	# TODO: compare to core base file list
	# BASEFILES=(".htaccess" "index.php" "wp-activate.php" "wp-blog-header.php" "wp-comments-post.php" "wp-config.php" "wp-config-sample.php" "wp-cron.php" "wp-links-opml.php" "wp-login.php" "wp-mail.php" "wp-settings.php" "wp-signup.php" "wp-trackback.php" "xmlrpc.php")
	BASEFILES=$(lsattr -l "$SITEPATH" | grep " Immutable")
	# | tee $LOCKFILE
	COUNT=$(echo -n "$BASEFILES" | grep -c '^')
	echo "$COUNT"" immutable base files"
	
	# - check lock for wp-includes dir files -
	if [ -d "$INCLUDES" ]; then
		INCFILES=$(lsattr -R -l "$INCLUDES" | grep " Immutable")
		# | tee -a $LOCKFILE
		COUNT=$(echo -n "$INCFILES" | grep -c '^') 
		echo "$COUNT"" immutable includes files"
	fi
	
	# - check lock for wp-admin dir files -
	if [ -d "$ADMIN" ]; then
		ADMINFILES=$(lsattr -R -l "$ADMIN" | grep " Immutable")
		# | tee -a $LOCKFILE
		COUNT=$(echo -n "$ADMINFILES" | grep -c '^')
		echo "$COUNT"" immutable admin files"
	fi
}

# ------------------------ #
# Check File Owners/Groups #
# ------------------------ #
function checkowners {

	# TODO: check owner permissions for alias
	if [ -n "$ALIAS" ]; then
		red "Error."; printf " Cannot check permissions for site aliases (yet.)"; echo ""; return
	fi


	# TODO: look only in wordpress paths

	# - check permissions -
	if [ -n "$SITEGROUP" ]; then
		# - check owner / group mismatches -
		yellow "*"; printf " Searching '"; green "$SITENAME"; echo "' for files with mismatching owner/group permissions..."
		OUTPUT=$(find "$SITEPATH" \( ! -user "$SITEUSER" -o ! -group "$SITEGROUP" \) )
	else 
		# - check for owner mismatches -
		yellow "*"; printf " Searching '"; green "$SITENAME"; echo "' for files with mismatching owner permissions..."
		OUTPUT=$(find "$SITEPATH" ! -user "$SITEUSER")
	fi
	echo "$OUTPUT"
}

# ---------------------- #
# Fix File Owners/Groups #
# ---------------------- #
function fixowners {
	
	# TODO: fix owner permissions for alias
	if [ -n "$ALIAS" ]; then
		red "Error."; printf " Cannot fix permissions for site aliases (yet.)"; echo ""; return
	fi
	
	# - maybe unlock core -
	if [ "$SITELOCKING" == "true" ]; then unlockcore; fi
	
	# - set core base files -
	BASEFILES=(".htaccess" "index.php" "wp-activate.php" "wp-blog-header.php" "wp-comments-post.php" "wp-config.php" "wp-config-sample.php" "wp-cron.php" "wp-links-opml.php" "wp-login.php" "wp-mail.php" "wp-settings.php" "wp-signup.php" "wp-trackback.php" "xmlrpc.php")
	
	# - fix permissions -
	if [ -n "$SITEGROUP" ]; then
		# - fix owner / group permissions -
		yellow "***"; printf " Fixing owner/group permissions on '"; green "$SITENAME"; echo "'..."
		#chown -R "$SITEUSER":"$SITEGROUP" "$SITEPATH"

		for BASEFILE in "${BASEFILES[@]}"; do
			chown "$SITEUSER":"$SITEGROUP" "$SITEPATH"/"$BASEFILE"
		done
		chown -R "$SITEUSER":"$SITEGROUP" "$SITEPATH"/wp-content
		chown -R "$SITEUSER":"$SITEGROUP" "$SITEPATH"/wp-admin
		chown -R "$SITEUSER":"$SITEGROUP" "$SITEPATH"/wp-includes
	else
		# - fix owner permissions -
		yellow "***"; printf " Fixing owner permissions on '"; green "$SITENAME"; echo "'..."
		chown -R "$SITEUSER" "$SITEPATH"
		
		for BASEFILE in "${BASEFILES[@]}"; do
		 	chown "$SITEUSER" "$SITEPATH"/"$BASEFILE"
		done
		chown -R "$SITEUSER" "$SITEPATH"/wp-content
		chown -R "$SITEUSER" "$SITEPATH"/wp-admin
		chown -R "$SITEUSER" "$SITEPATH"/wp-includes
	fi

	# - maybe relock core -	
	if [ "$SITELOCKING" == "true" ]; then lockcore; fi
}


# ----------------------- #
# === PLUGIN COMMANDS === #
# ----------------------- #

# ------------ #
# List Plugins #
# ------------ #
# 1.0.3: renamed from checkplugin, deprecated old listplugin function
function listplugins {
	
	local PLUGIN; PLUGIN=$1

	# - output checking plugins message -
	yellow "*"; printf " Checking for plugin(s) on "; green "$SITENAME"; echo ": "
	
	# - get plugin list -
	INFO=$(sudo -u "$SITEUSER" "$WP" plugin list --fields=name,status,version,update,update_version --skip-plugins --format=csv | tail -n +2)

	# - get all listed plugins -
	I=0; ALLPLUGINS=(); LINES=()
	while IFS= read -r -a LINE; do
		ALLPLUGINS[$I]=$(awk -F',' '{print $1}' <<< "$LINE"); 
		LINES[$I]=$LINE; ((++I))
	done <<< "$INFO"

	# - empty = list all plugins -
	if [ -z "$PLUGIN" ]; then
		PLUGINS=("${ALLPLUGINS[@]}")		 
	else
		# - read specified plugins -
		IFS="," read -r -a PLUGINS <<< "$PLUGIN"

		# - check for limit switches -
		I=0; NEWPLUGINS=()
		ALL=""; ACTIVES=""; INACTIVES=""; MUSTUSES=""; DROPINS=""; UPDATES=""; CHANGED=""
		for APLUGIN in "${PLUGINS[@]}"; do
			REMOVE=""
			if [ "$APLUGIN" == "all" ]; then ALL="true"; fi
			if [ "$APLUGIN" == "actives" ]; then ACTIVES="true"; REMOVE="true"; CHANGED="true"; fi
			if [ "$APLUGIN" == "inactives" ]; then INACTIVES="true"; REMOVE="true"; CHANGED="true"; fi
			if [ "$APLUGIN" == "mustuses" ]; then MUSTUSES="true"; REMOVE="true"; CHANGED="true"; fi
			if [ "$APLUGIN" == "dropins" ]; then DROPINS="true"; REMOVE="true"; CHANGED="true"; fi
			if [ "$APLUGIN" == "updates" ]; then UPDATES="true"; REMOVE="true"; CHANGED="true"; fi
			if [ !"$REMOVE" == "true" ]; then NEWPLUGINS[$I]=$APLUGIN; ((++I)); fi
		done

		# - reassign if changed -
		if [ "$CHANGED" == "true" ]; then PLUGINS=("${NEWPLUGINS[@]}"); fi
		if [ "$ALL" == "true" ] || [ -z "$PLUGINS" ]; then PLUGINS=("${ALLPLUGINS[@]}"); fi
	fi

	# - table headings -
	TABLE=""; OTHER=""
	TABLE+=$(white "PLUGIN"); TABLE+="|"
	TABLE+=$(white "STATUS"); TABLE+="|"
	TABLE+=$(white "VERSION"); TABLE+="|"
	TABLE+=$(white "UPDATES"); TABLE+=$'\r\n'
		
	# - loop plugins -
	I=0; MATCH=""
	for APLUGIN in "${ALLPLUGINS[@]}"; do
	
		ACTIVE=""; INACTIVE=""; MUSTUSE=""; DROPIN=""; UPDATE=""

		# - get plugin info -
		PLUGININFO=${LINES[$I]}

		if [ -n "$PLUGININFO" ]; then

			ROW=$(cyan "$APLUGIN")

			# - split by tabs while preserving columns -
			# ref: https://stackoverflow.com/a/19726834/5240159
			# if [[ ! "$PLUGININFO" == *$'\t' ]]; then PLUGININFO+=$'\t'; fi
			# COLUMNS=()
			# while IFS='' read -r -d$'\t' COLUMN; do
			#   COLUMNS+=("$COLUMN")
			# done <<< "$PLUGININFO"

			# - simplified to split by CSV format -
			IFS=',' read -r -a COLUMNS <<< "$PLUGININFO"

			# - plugin status -
			ROW+="|"
			if [ "${COLUMNS[1]}" == "active" ]; then
				ROW+=$(green "Active"); ACTIVE="true"
			else
				if [ "${COLUMNS[1]}" == "must-use" ]; then
					ROW+=$(magenta "Must Use"); MUSTUSE="true"
				else
					if [ "${COLUMNS[1]}" == "dropin" ]; then
						ROW+=$(magenta "Dropin"); DROPIN="true"
					else 
						ROW+=$(blue "Inactive"); INACTIVE="true"
					fi
				fi
			fi

			# - plugin version -
			ROW+="|"; 
			if [ -n "${COLUMNS[2]}" ]; then
				ROW+=$(yellow "${COLUMNS[2]}")
			else 
				ROW+="-"
			fi

			# - plugin updates -
			if [ "${COLUMNS[3]}" == "available" ]; then
				ROW+="|"; ROW+=$(yellow "${COLUMNS[4]}"); ROW+=" available"
				UPDATE="true"
			fi
		# else 	
		#	ROW+="|"; ROW+=$(red "Not Found")
		fi

		# - add row new line -
		ROW+=$'\r\n'

		# - add row if listing all -
		ADDROW=""
		if [ "$ALL" == "true" ]; then ADDROW="true"
		else 
			# - add row if matching a plugin limit filter -
			if [ "$UPDATES" == "true" -a "$UPDATE" == "true" ] \
				|| [ "$ACTIVES" == "true" -a "$ACTIVE" == "true" ] \
				|| [ "$INACTIVES" == "true" -a "$INACTIVE" == "true" ] \
				|| [ "$MUSTUSES" == "true" -a "$MUSTUSE" == "true" ] \
				|| [ "$DROPINS" == "true" -a "$DROPIN" == "true" ]; then
				ADDROW="true"
			fi

			# - check for matching plugin slug -
			if [ -z "$ADDROW" ]; then
				for PLUGIN in "${PLUGINS[@]}"; do
					# echo $PLUGIN" - "$APLUGIN
					if [ "$PLUGIN" == "$APLUGIN" ]; then
						ADDROW="true"
					fi
				done
			fi
		fi

		# - split table rows according to active status -
		if [ "$ADDROW" == "true" ]; then
			MATCH="true"
			if [ "$ACTIVE" == "true" ]; then TABLE+=$ROW			
			else OTHER+=$ROW; fi
		fi

		((++I))
		
	done

	if [ "$MATCH" == "true" ]; then
		# - add all other rows to active rows -
		TABLE+=$OTHER

		# - output pretty table -	
		OUTPUT=$(column -t -s "|" <<< "$TABLE")
		echo "$OUTPUT"
	else 
		# - output no match found -
		red "Sorry."; echo " No matching plugins found."
	fi
}

# -------------- #
# Install Plugin #
# -------------- #
function installplugin {

	local PLUGIN; PLUGIN=$1
	SUCCESS="Plugin installed successfully."
	
	# - loop plugins -
	IFS="," read -r -a PLUGINS <<< "$PLUGIN"
	for PLUGIN in "${PLUGINS[@]}"; do
	
		# - output installing plugin message -
		yellow "***"; printf " Installing plugin "; cyan "$PLUGIN"; printf " on "; green "$SITENAME"; echo "..."
		
		# - set command and execute -
		COMMAND="sudo -u ""$SITEUSER"" ""$WP"" plugin install ""$PLUGIN"" --skip-plugins"
		OUTPUT=$($COMMAND)
		
		# - check result and maybe try again
		checkresult "$OUTPUT" "$SUCCESS"
		if [ "$RESULT" == "failed" ]; then OUTPUT=$($COMMAND); fi

		echo "$OUTPUT"
	done
}

# --------------------------- #
# Install and Activate Plugin #
# --------------------------- #
function installactivateplugin {
	
	local PLUGIN; PLUGIN=$1

	# - loop plugins -
	IFS="," read -r -a PLUGINS <<< "$PLUGIN"
	for PLUGIN in "${PLUGINS[@]}"; do
		
		# - output installing plugin message -
		yellow "****"; printf " Installing and activating plugin "; cyan "$PLUGIN"; printf " on "; green "$SITENAME"; echo "..."
		
		# - install plugin -
		installplugin "$PLUGIN"
		
		# - activate the plugin if installed -
		if [ "$RESULT" == "success" ]; then activateplugin "$PLUGIN"; fi
	done
}

# ---------------- #
# Reinstall Plugin #
# ---------------- #
function reinstallplugin {
	
	local PLUGIN=$1

	# - loop plugins -
	IFS="," read -r -a PLUGINS <<< "$PLUGIN"
	for PLUGIN in "${PLUGINS[@]}"; do

		# TODO: backup plugin before deleting? (as install may fail?)
	
		# - output reinstalling plugin message -
		yellow "****"; printf " Reinstalling plugin "; cyan "$PLUGIN"; printf " on "; green "$SITENAME"; echo "..."
		
		# - delete existing plugin -
		deleteplugin "$PLUGIN"
		
		# - install plugin -
		if [ "$RESULT" == "success" ]; then installplugin "$PLUGIN"; fi
		
		# TODO: restore plugin backup on failure
		
	done
}

# ---------------- #
# Uninstall Plugin #
# ---------------- #
function uninstallplugin {
	
	local PLUGIN; PLUGIN=$1
	SUCCESS="Uninstalled and deleted"
	
	# - loop plugins -
	IFS="," read -r -a PLUGINS <<< "$PLUGIN"
	for PLUGIN in "${PLUGINS[@]}"; do
	
		# - output uninstalling plugin message -
		yellow "***"; printf " Uninstalling plugin "; cyan "$PLUGIN"; printf " from "; green "$SITENAME"; echo "..."
		
		# - set and execute command -
		COMMAND="sudo -u ""$SITEUSER"" ""$WP"" plugin uninstall ""$PLUGIN"" --skip-plugins"
		OUTPUT=$($COMMAND)
		
		# - check result and maybe try again -
		checkresult "$OUTPUT" "$SUCCESS"
		if [ "$RESULT" == "failed" ]; then OUTPUT=$($COMMAND); fi
		
		echo "$OUTPUT"
	done
}

# --------------- #
# Activate Plugin #
# --------------- #
function activateplugin {
	
	local PLUGIN; PLUGIN=$1
	SUCCESS="Success: Plugin"
	
	# - loop plugins
	IFS="," read -r -a PLUGINS <<< "$PLUGIN"
	for PLUGIN in "${PLUGINS[@]}"; do
	
		# - output activating plugin message -
		yellow "***"; printf " Activating plugin "; cyan "$PLUGIN"; printf " on "; green "$SITENAME"; echo "..."
		
		# - set and execute command -
		COMMAND="sudo -u ""$SITEUSER"" ""$WP"" plugin activate ""$PLUGIN"" --skip-plugins"
		OUTPUT=$($COMMAND)
		
		# - check result and maybe try again -
		checkresult "$OUTPUT" "$SUCCESS"
		if [ "$RESULT" == "failed" ]; then OUTPUT=$($COMMAND); fi
		
		echo "$OUTPUT"
	done
}

# ----------------- #
# Deactivate Plugin #
# ----------------- #
function deactivateplugin {
	
	local PLUGIN; PLUGIN=$1
	SUCCESS="Success: Deactivated"
	
	# - loop plugins -
	IFS="," read -r -a PLUGINS <<< "$PLUGIN"
	for PLUGIN in "${PLUGINS[@]}"; do
		
		# - output deactivating plugin message -
		yellow "***"; printf " Deactivating plugin "; cyan "$PLUGIN"; printf " on "; green "$SITENAME"; echo "..."
		
		# - set and execute command -
		COMMAND="sudo -u ""$SITEUSER"" ""$WP"" plugin deactivate ""$PLUGIN"" --skip-plugins"
		OUTPUT=$($COMMAND)
		
		# - check result and maybe try again -
		checkresult "$OUTPUT" "$SUCCESS"
		if [ "$RESULT" == "failed" ]; then OUTPUT=$($COMMAND); fi
		
		echo "$OUTPUT"
	done
}

# ------------- #
# Delete Plugin #
# ------------- #
function deleteplugin {
	
	local PLUGIN; PLUGIN=$1
	SUCCESS="Success: Deleted"	
	
	# - loop plugins -
	IFS="," read -r -a PLUGINS <<< "$PLUGIN"
	for PLUGIN in "${PLUGINS[@]}"; do

		# - deactivate plugin first -
		deactivateplugin "$PLUGIN"

		# - output delete plugin message -
		yellow "***"; printf " Deleting plugin "; cyan "$PLUGIN"; printf " on "; green "$SITENAME"; echo "..."
		
		# - set command and execute -
		COMMAND="sudo -u ""$SITEUSER"" ""$WP"" plugin delete ""$PLUGIN"" --skip-plugins"		
		OUTPUT=$($COMMAND)
	
		# - check result and maybe force delete plugin -
		checkresult "$OUTPUT" "$SUCCESS"
		if [ "$RESULT" == "failed" ]; then
			if [ -z "$ALIAS" ]; then
				red "Failed"; printf ": Could not delete plugin "; cyan "$PLUGIN"; echo "."
			else
				PLUGINPATH="$SITEPATH"wp-content/plugins/"$PLUGIN"
				if [ -d "$PLUGINPATH" ]; then
					sudo -u "$SITEUSER" rm -rf "$PLUGINPATH"
					if [ -d "$PLUGINPATH" ]; then
						red "Failed"; printf ": Could not delete plugin "; cyan "$PLUGIN"; printf " on site "; green "$SITENAME"; echo "."
						RESULT="failed"
					else 
						RESULT="success"; yellow "Manually Deleted plugin"; cyan "$PLUGIN"; printf " on site "; green "$SITENAME"; echo "."
					fi
				fi
			fi
		fi
	done
}

# ------------- #
# Update Plugin #
# ------------- #
function updateplugin {
	
	local PLUGIN; PLUGIN="$1"
	SUCCESS="Plugin updated successfully."
	
	# IDEA: get plugin list before updates and compare with after
	
	# - maybe update all plugins -
	if [ "$PLUGIN" == "all" ]; then
	
		# [Deprecated] use --all switch
		# updateallplugins; return

		# TODO: maybe add an update all plugins confirmation prompt ?

		# - output updating all plugins message -
		yellow "****"; printf " Updating "; cyan "ALL"; printf " plugins on "; green "$SITENAME"; echo "..."

		# - get plugin list -
		INFO=$(sudo -u "$SITEUSER" "$WP" plugin list --fields=name --skip-plugins | tail -n +2)

		# TODO: convert list to plugin array
		
		
		# TEMP
		echo "Unfinished feature"; exit 1
	fi
	
	# - loop plugins -
	IFS="," read -r -a PLUGINS <<< "$PLUGIN"
	for PLUGIN in "${PLUGINS[@]}"; do

		# - maybe split plugin by plugin-slug:version -
		VERSION=""
		if [[ "$PLUGIN" == *":"* ]]; then
			IFS=":" read -r -a PLUGININFO <<< "$PLUGIN"
			PLUGIN=${PLUGININFO[0]}
			VERSION=${PLUGININFO[1]}
		fi

		# - set command -
		if [ -n "$VERSION" ]; then
			if [ "$VERSION" == "minor" ] || [ "$VERSION" == "patch" ]; then
				# - update to minor/patch version -
				yellow "***"; printf " Updating plugin "; cyan "$PLUGIN"; printf " on "; green "$SITENAME"; printf " ("; yellow "$VERSION"; echo " only)..."
				COMMAND="sudo -u ""$SITEUSER"" ""$WP"" plugin update ""$PLUGIN"" --""$VERSION"" --skip-plugins"
			else
				# - update to specific version -
				yellow "***"; printf " Updating plugin "; cyan "$PLUGIN"; printf " on "; green "$SITENAME"; printf " to version "; yellow "$VERSION"; echo "..."
				COMMAND="sudo -u ""$SITEUSER"" ""$WP"" plugin update ""$PLUGIN"" --version=""$VERSION"" --skip-plugins"
			fi
		else 
			# - update to latest version
				yellow "***"; printf " Updating plugin "; cyan "$PLUGIN"; printf " on "; green "$SITENAME"; echo "..."
			COMMAND="sudo -u ""$SITEUSER"" ""$WP"" plugin update ""$PLUGIN"" --skip-plugins"
		fi

		# - execute command -
		OUTPUT=$($COMMAND)

		# - check result and maybe try again -
		checkresult "$OUTPUT" "$SUCCESS"
		if [ "$RESULT" == "failed" ]; then OUTPUT=$($COMMAND); fi

		echo "$OUTPUT"
	done
}


# ---------------------- #
# === THEME COMMANDS === #
# ---------------------- #

# ----------- #
# List Themes #
# ----------- #
function listthemes {

	local THEME; THEME=$1

	# - output listing themes message -
	yellow "*"; printf " Listing theme(s) for "; green "$SITENAME"; echo "..."

	# - get template / stylesheet options -
	TEMPLATE=$(sudo -u "$SITEUSER" "$WP" option get template --skip-plugins)
	STYLESHEET=$(sudo -u "$SITEUSER" "$WP" option get stylesheet --skip-plugins)

	# - get all theme info -	
	INFO=$(sudo -u "$SITEUSER" "$WP" theme list --fields=name,status,version,update,update_version --skip-plugins --format=csv| tail -n +2)

	# - check for empty / 'all' -
	if [ -z "$THEME" ]; then THEME="all"; fi
	if [ "$THEME" == "all" ]; then
		THEMES=()
		while IFS= read -r -a LINE; do
			THEMES+=($(awk -F',' '{print $1}' <<< "$LINE"))
		done <<< "$INFO"
	else 
		IFS="," read -r -a THEMES <<< "$THEME"
	fi

	# - table headings -
	TABLE=""; OTHER=""
	TABLE+=$(white "THEME"); TABLE+="|"
	TABLE+=$(white "STATUS"); TABLE+="|"
	TABLE+=$(white "VERSION"); TABLE+="|"
	TABLE+=$(white "UPDATES"); TABLE+=$'\r\n'

	# - loop themes -
	for THEME in "${THEMES[@]}"; do
	
		ROW=$(cyan "$THEME")
		ACTIVE=""

		THEMEINFO=$(grep "$THEME" <<< "$INFO")
		if [ -n "$THEMEINFO" ]; then

			# - split tabs while preserving columns -
			# ref: https://stackoverflow.com/a/19726834/5240159
			# if [[ ! "$THEMEINFO" == *$'\t' ]]; then THEMEINFO+=$'\t'; fi
			# COLUMNS=()
			# while IFS='' read -r -d$'\t' COLUMN; do
			#   COLUMNS+=("$COLUMN")
			# done <<< "$THEMEINFO"

			# - simplifed to split by CSV -
			IFS=',' read -r -a COLUMNS <<< "$THEMEINFO"

			# - theme status -
			ROW+="|"
			if [ "${COLUMNS[1]}" == "active" ]; then
				ROW+=$(green "Active")
				ACTIVE="true"
			else
				ROW+=$(blue "Inactive")
			fi

			# - theme version -
			ROW+="|"; 
			if [ -n "${COLUMNS[2]}" ]; then
				ROW+=$(yellow "${COLUMNS[2]}")
			else 
				ROW+="-"
			fi

			# - theme updates -
			if [ "${COLUMNS[3]}" == "available" ]; then
				ROW+="|"; ROW+=$(yellow "${COLUMNS[4]}"); ROW+=" available"
			fi
		else 	
			ROW+="|"; ROW+=$(red "Not Found")
		fi

		ROW+=$'\r\n'

		# - split table rows according to active status -
		if [ "$ACTIVE" == "true" ]; then
			TABLE+=$ROW
		else 
			OTHER+=$ROW
		fi

	done

	# - add all other rows to active rows -
	TABLE+=$OTHER

	# - output new pretty table -
	OUTPUT=$(column -t -s "|" <<< "$TABLE")
	echo "$OUTPUT"
}

# ----------- #
# Check Theme #
# ----------- #
function checktheme {
	
	local TEMPLATE; local TEMPLATEPATH; local TEMPLATEVERSION
	local STYLESHEET; local STYLEPATH; local STYLEVERSION
	
	# TODO: check theme for alias
	if [ -n "$ALIAS" ]; then
		red "Error."; printf " Cannot reinstall plugins for site aliases (yet.)"; echo ""; return
	fi
	
	# - get template and stylesheet options -
	TEMPLATE=$(sudo -u "$SITEUSER" "$WP" option get template --skip-plugins)
	STYLESHEET=$(sudo -u "$SITEUSER" "$WP" option get stylesheet --skip-plugins)
	
	if [ -n "$TEMPLATE" ]; then
	
		green "$SITENAME";

		# - get template version from style.css -
		# TODO: get version via theme list info instead
		TEMPLATEPATH="$SITEPATH""wp-content/themes/""$TEMPLATE""/style.css"
		# note: use -m 1 to ensure getting first line match only
		TEMPLATEVERSION=$(grep -m 1 'Version:' "$TEMPLATEPATH" | awk '{print $2}' | tr -d '\r')

		# - check if theme updates are  available -
		COMMAND="sudo -u ""$SITEUSER"" ""$WP"" theme list --fields=name,update,update_version --skip-plugins | tail -n +2"
		OUTPUT=$($COMMAND)

		if [ "$TEMPLATE" == "$STYLESHEET" ]; then
		
			# - output theme version -
			printf " Theme: "; cyan "$TEMPLATE"; printf " "; yellow "$TEMPLATEVERSION"; printf " (Parent - no Child Theme)"
			
			# - check if theme update is available -
			# (loop lines for exact slug match)
			IFS="" read -r -a LINES <<< "$UPDATES"
			for LINE in "${LINES[@]}"; do
				THEME=$(awk '{print $1}' <<< "$LINE")
				if [ "$THEME" == "$TEMPLATE" ]; then
					AVAILABLE=$(awk '{print $2}' <<< "$LINE")
					if [ "$AVAILABLE" == 'available' ]; then
						VERSION=$(awk '{print $3}' <<< "$LINE")
						printf "(Update to "; yellow "$VERSION"; printf " available.)"
					fi
				fi				
			done
			
		else 
			# - get stylesheet version from style.css -
			STYLEPATH="$SITEPATH""wp-content/themes/""$STYLESHEET""/style.css"
			# note: use -m 1 to ensure getting first line match only
			# TODO: get version via theme list instead
			STYLEVERSION=$(grep -m 1 'Version:' "$STYLEPATH" | awk '{print $2}' | tr -d '\r')

			# - output parent and child theme versions -
			printf " - Child Theme "; cyan "$STYLESHEET"; printf " "; yellow "$STYLEVERSION"
			printf " - Parent Theme: "; cyan "$TEMPLATE"; printf " "; yellow "$TEMPLATEVERSION"
						
			# - output message for parent theme update -
			# (loop lines for exact slug match)
			IFS="" read -r -a LINES <<< "$OUTPUT"
			for LINE in "${LINES[@]}"; do
				THEME=$(awk '{print $1}' <<< "$LINE")
				if [ "$THEME" == "$TEMPLATE" ]; then
					AVAILABLE=$(awk '{print $2}' <<< "$LINE")
					if [ "$AVAILABLE" == 'available' ]; then
						VERSION=$(awk '{print $3}' <<< "$LINE")
						echo ""; printf "Parent Theme Update to "; yellow "$VERSION"; printf " available."
					fi
				fi
			done
			
			# - output message for child theme update -
			for LINE in "${LINES[@]}"; do
				THEME=$(awk '{print $1}' <<< "$LINE")
				if [ "$THEME" == "$STYLESHEET" ]; then
					AVAILABLE=$(awk '{print $2}' <<< "$LINE")
					if [ "$AVAILABLE" == 'available' ]; then
						VERSION=$(awk '{print $3}' <<< "$LINE")
						echo ""; printf "Child Theme Update to "; yellow "$VERSION"; printf " available."
					fi
				fi
			done
		fi
		echo ""
	else
		red "Warning:"; printf " could not retrieve template option value for "; yellow "$SITENAME"; echo " "
	fi
}

# -------------- #
# Activate Theme #
# -------------- #
function activatetheme {

	local THEME; THEME=$1
	SUCCESS="Switched to"

	# TODO: maybe handle multisite theme activation for specified blog ID ?
	
	if [[ "$THEME" == *","* ]]; then
		# - output only activate one theme message -
		red "Failed! You cannot activate multiple themes. Choose one!"; echo "";
	else 
		# - output activating theme message -
		yellow "***"; printf " Activating theme "; cyan "$THEME"; printf " on "; green "$SITENAME"; echo "..."

		# - set command and execute -
		COMMAND="sudo -u ""$SITEUSER"" ""$WP"" theme activate ""$THEME"" --skip-plugins"
		OUTPUT=$($COMMAND)
		
		# - check result and maybe try again -
		checkresult "$OUTPUT" "$SUCCESS"
		if [ "$RESULT" == "failed" ]; then OUTPUT=$($COMMAND); fi

		echo "$OUTPUT"
	fi
}

# ------------- #
# Install Theme #
# ------------- #
function installtheme {
	
	local THEMES; THEMES=$1
	SUCCESS="Theme installed successfully."
	
	# - loop themes -
	IFS="," read -r -a THEMESLUGS <<< "$THEMES"
	for THEME in "${THEMESLUGS[@]}"; do

		# - output installing themes message -
		yellow "***"; printf " Installing theme(s) "; cyan "$THEME"; printf " on "; green "$SITENAME"; echo "..."

		# - set command and execute -
		COMMAND="sudo -u ""$SITEUSER"" ""$WP"" theme install ""$THEME"" --skip-plugins"
		OUTPUT=$($COMMAND)
		
		# - check result and maybe try again -
		checkresult "$OUTPUT" "$SUCCESS"
		if [ "$RESULT" == "failed" ]; then OUTPUT=$($COMMAND); fi

		echo "$OUTPUT"
	done
}

# ---------------------- #
# Install Activate Theme #
# ---------------------- #
function installactivatetheme {

	local THEME; THEME=$1
	
	if [[ "$THEME" == *","* ]]; then
		# - output cannot activate multiple themes message -
		red "Error!"; sprintf " You cannot activate multiple themes. Choose one!"; echo "";
	else 
		# - output installing and activating theme message -
		yellow "***"; printf " Installing and activating theme "; cyan "$THEME"; printf " on site "; green "$SITENAME"; echo "..."

		# - install specified theme -
		installtheme "$THEME"

		# - activate if install successful -
		if [ "$RESULT" == 'success' ]; then activatetheme "$THEME"; fi
	fi
}

# --------------- #
# Reinstall Theme #
# --------------- #
function reinstalltheme {
	
	local THEMES; THEMES=$1
	
	# TODO: reinstall theme for alias
	if [ -n "$ALIAS" ]; then
		red "Error."; printf " Cannot reinstall themes for site aliases (yet.)"; echo ""; return
	fi
	
	# - loop themes
	IFS="," read -r -a THEMESLUGS <<< "$THEMES"
	for THEME in "${THEMESLUGS[@]}"; do
	
		# - output reinstalling theme message -
		yellow "***"; printf " Reinstalling theme(s) "; cyan "$THEME"; printf " on site "; green "$SITENAME"; echo "..."

		# - backup existing theme -
		THEMEPATH="$SITEPATH""wp-content/""$THEME""/"
		BACKUPPATH="$SITEPATH""wp-content/""$THEME""-backup/"
		sudo -u "$SITEUSER" rm -rf "$BACKUPPATH"
		sudo -u "$SITEUSER" mv "$THEMEPATH" "$BACKUPPATH"
		
		# - reinstall theme -
		installtheme "$THEME"
		
		# TODO: check for failure to maybe restore backup
		# if [ "$RESULT" == "failed" ]; then
		#	sudo -u "$SITEUSER" rm -rf "$THEMEPATH"
		#	sudo -u "$SITEUSER" mv "$BACKUPPATH" "$THEMEPATH" 
		# fi
	done
}

# ------------ #
# Update Theme #
# ------------ #
function updatetheme {
	
	local THEMES; THEMES=$1
	SUCCESS="Theme updated successfully."
	
	# - maybe update all themes -
	if [ "$THEMES" == "all" ]; then
	
		# [deprecated] use --all switch for update -
		# OUTPUT=$(sudo -u "$SITEUSER" wp theme update --all --skip-plugins)

		# - output updating all themes message -
		yellow "****"; printf " Updating "; cyan "ALL"; printf " themes on "; green "$SITENAME"; echo "..."

		# - get theme list -
		INFO=$(sudo -u "$SITEUSER" "$WP" theme list --fields=name --skip-plugins | tail -n +2)	
		
		# TODO: - convert list to themes array -
		
		# TEMP
		echo "Unfinished feature"; exit 1
	fi
		
	# - loop themes -
	IFS="," read -r -a THEMESLUGS <<< "$THEMES"
	for THEME in "${THEMESLUGS[@]}"; do
	
		# - maybe split theme into themeslug:version -
		VERSION=""
		if [[ "$THEME" == *":"* ]]; then
			IFS=":" read -r -a THEMEINFO <<< "$THEME"
			THEME=${THEMEINFO[0]}
			VERSION=${THEMEINFO[1]}
		fi

		# - set command -
		if [ -n "$VERSION" ]; then
			if [ "$VERSION" == "minor" ] || [ "$VERSION" == "patch" ]; then
				# - update to minor/patch version -
				yellow "***"; printf " Updating theme "; cyan "$THEME"; printf " on site "; green "$SITENAME"; printf " ("; yellow "$VERSION"; echo " only)..."
				COMMAND="sudo -u ""$SITEUSER"" ""$WP"" theme update ""$THEME"" --skip-plugins"
			else
				# - update to specific version -
				yellow "***"; printf " Updating theme "; cyan "$THEME"; printf " on site "; green "$SITENAME"; printf " to version "; yellow "$VERSION"; echo "..."
				COMMAND="sudo -u ""$SITEUSER"" ""$WP"" theme update ""$THEME"" --skip-plugins"
			fi
		else
			# - update to latest version -
			yellow "***"; printf " Updating theme "; cyan "$THEME"; printf " on site "; green "$SITENAME"; echo "..."
			COMMAND="sudo -u ""$SITEUSER"" ""$WP"" theme update ""$THEME"" --skip-plugins"
		fi
		
		# - execute command -
		OUTPUT=$($COMMAND)
		
		# - check result and maybe try again -
		checkresult "$OUTPUT" "$SUCCESS"
		if [ "$RESULT" == "failed" ]; then OUTPUT=$($COMMAND); fi
		
		echo "$OUTPUT"
	done	
}


# --------------------- #
# === SYNC COMMANDS === #
# --------------------- #

# --------- #
# Sync Core #
# --------- #
function synccore {

	local SOURCETYPE; local SOURCESLUG; local SOURCEPATH
	local CORESLUG; CORESLUG=$1; 

	# TODO: sync core for YML configs
	if [ -n "$YMLPATH" ]; then
		red "Error."; printf " Cannot sync core for YML configs (yet.)"; echo ""; return
	fi

	# TODO: sync core for alias
	if [ -n "$ALIAS" ]; then
		red "Error."; printf " Cannot sync core for site aliases (yet.)"; echo ""; return
	fi

	# - maybe unlock core -	
	if [ "$SITELOCKING" == "true" ]; then unlockcore; fi

	# - read sources config -
	while IFS= read -r -a SOURCE || [ -n "$SOURCE" ]; do

		# - ignore lines starting with # -
		if [ ! "${SOURCE:0:1}" == "#" ]; then

			# - expand source data -
			# TODO: expand with read
			IFS=" " read -r -a DATA <<< "$SOURCE"
			SOURCETYPE=${DATA[0]}
			SOURCESLUG=${DATA[1]}
			SOURCEPATH=$(echo "${DATA[2]}" | tr -d '\r')

			if [ "$SOURCETYPE" == "core" ]; then

				# TODO: handle .zip source files?
				# if [ -f "$SOURCEPATH" ]; then
				#	if [ ?is-zip? "$SOURCEPATH" ]; then
				# 		COREZIP="true"
				#		...extract zip to a temp dir...
				#		SOURCEPATH="$TEMPDIR"
				#	fi
				# fi

				# - sync core from source -
				if [ -d "$SOURCEPATH" ]; then
					if [ "$CORESLUG" == "$SOURCESLUG" ]; then
					
						# - output syncing core message -
						yellow "***"; printf " Syncing Core "; cyan "$SOURCESLUG"; printf " to site "; green "$SITENAME"; echo "..."
					
						# TODO: maybe use rsync --backup option?
						sudo -u "$SITEUSER" rsync -av --delay-updates "$SOURCEPATH" "$SITEPATH"
						RESULT="success"
					fi
				else
					# - output invalid source directory message -
					red "Warning: "; printf "Invalid source directory, check "; white "wpx.conf"; printf " for "; yellow "$SOURCESLUG"; printf ". Skipping..."; echo " "
				fi

			fi
		fi
	done < "$CONFIG"

	# - maybe relock core -
	if [ "$SITELOCKING" == "true" ]; then lockcore; fi
}

# ----------- #
# Sync Plugin #
# ----------- #
function syncplugin {
	
	local SOURCETYPE; local SOURCESLUG; local SOURCEPATH; local PLUGINPATH; local DOSYNC
	local PLUGIN; PLUGIN=$1;

	# TODO: sync plugin for YML configs
	if [ -n "$YMLPATH" ]; then
		red "Error."; printf " Cannot sync plugins for YML configs (yet.)"; echo ""; return
	fi

	# TODO: sync plugin for alias
	if [ -n "$ALIAS" ]; then
		red "Error."; printf " Cannot sync plugins for site aliases (yet.)"; echo ""; return
	fi

	# - read file without requiring it to end in a new line -
	# ref: https://stackoverflow.com/a/31398490/5240159
	while IFS= read -r -a SOURCE || [ -n "$SOURCE" ]; do

		# - ignore lines starting with # -
		if [ ! "${SOURCE:0:1}" == "#" ]; then

			# - expand source data -
			IFS=" " read -r -a DATA <<< "$SOURCE"
			SOURCETYPE=${DATA[0]}
			SOURCESLUG=${DATA[1]}
			SOURCEPATH=$(echo "${DATA[2]}" | tr -d '\r')

			if [ "$SOURCETYPE" == "plugin" ]; then

				# TODO: handle .zip source files?
				# if [ -f $SOURCEPATH ]; then
				#	if [ ?is-zip? $SOURCEPATH ]; then
				# 		PLUGINZIP="true"
				#		...extract zip to temp dir...
				#		SOURCEPATH=$TEMPDIR
				#	fi
				# fi

				if [ -d "$SOURCEPATH" ]; then

					# - reset do sync flag -
					DOSYNC=""

					# - maybe split source reference to get actual plugin slug -
					# (useful for syncing development versions with same slug)
					ACTUALSLUG=""
					if [[ "$SOURCESLUG" == *":"* ]]; then
						IFS=":" read -r -a SLUGINFO <<< "$SOURCESLUG"
						SOURCESLUG=${SLUGINFO[0]}
						ACTUALSLUG=${SLUGINFO[1]}
						yellow "*"; white " Using source reference "; cyan "$SOURCESLUG"; white " for plugin slug "; cyan "$ACTUALSLUG"; echo ""
					fi

					# - match plugin slugs -
					if [ "$PLUGIN" == "all" ] || [ "$PLUGIN" == "$SOURCESLUG" ]; then 
						DOSYNC="true"
					else
						if [[ "$PLUGIN" == *","* ]]; then
							IFS="," read -r -a PLUGINS <<< "$PLUGIN"
							for PLUGINSLUG in "${PLUGINS[@]}"; do
								if [ "$PLUGINSLUG" == "$SOURCESLUG" ]; then DOSYNC="true"; fi
							done
						fi
					fi
					
					# - maybe set actual slug (if split) -
					if [ -n "$ACTUALSLUG" ]; then SOURCESLUG="$ACTUALSLUG"; fi

					# - maybe sync now -
					if [ "$DOSYNC" == "true" ]; then

						# - maybe create plugin dir -
						PLUGINPATH="$SITEPATH""wp-content/plugins/""$SOURCESLUG""/"
						if [ ! -d "$PLUGINPATH" ]; then
							sudo -u "$SITEUSER" mkdir "$PLUGINPATH"
							chown "$SITEUSER" "$PLUGINPATH"
						fi

						# - output plugin sync message -
						printf "Syncing Plugin "; cyan "$SOURCESLUG"; printf " to site "; green "$SITENAME"; echo " "

						# - sync plugin from source -
						# TODO: maybe use rsync --backup option?
						sudo -u "$SITEUSER" rsync -av --delete --delay-updates "$SOURCEPATH" "$PLUGINPATH"

						# - output synced info -							
						printf "Plugin Path: "; cyan "$SOURCEPATH"; echo "";
						printf "Synced to: "; green "$PLUGINPATH"; echo " "

						RESULT="success"
					fi

				else
					# - output invalid source directory message -
					red "Warning: "; printf "Invalid source directory, check "; white "wpx.conf"; printf " for "; yellow "$SOURCESLUG"; printf ". Skipping..."; echo " "
				fi

			fi
		fi
	done < "$CONFIG"

	if [ ! "$RESULT" == "success" ]; then
		# - no matching plugin slug message -
		red "Error!"; printf " No matching plugin slug found, check "; white "wpx.conf"; printf " for "; yellow "$PLUGIN"; echo "."
	fi
}

# ------------------------ #
# Sync and Activate Plugin #
# ------------------------ #
function syncactivateplugin {

	local PLUGIN; PLUGIN=$1

	# TODO: sync activate plugin for YML configs
	if [ -n "$YMLPATH" ]; then
		red "Error."; printf " Cannot sync and activate plugins for YML configs (yet.)"; echo ""; return
	fi

	# TODO: sync activate plugin for alias
	if [ -n "$ALIAS" ]; then
		red "Error."; printf " Cannot sync and activate plugins for site aliases (yet.)"; echo ""; return
	fi

	# - loop plugin slugs -
	IFS="," read -r -a PLUGINS <<< "$PLUGIN"
	for PLUGIN in "${PLUGINS[@]}"; do
	
		# - output syncing and activating message -
		yellow "****"; printf " Syncing and activating plugin "; cyan "$PLUGIN"; printf " on "; green "$SITENAME"; echo "..."
		
		# - sync plugin -
		syncplugin "$PLUGIN"

		# - check syncing result before activating -
		if [ -n "$ACTUALSLUG" ]; then PLUGIN="$ACTUALSLUG"; fi
		if [ "$RESULT" == "success" ]; then
			activateplugin "$PLUGIN"
		else 
			red "Failed!"; printf "Plugin "; cyan "$PLUGIN"; echo "not activated."
		fi
	done
}

# ---------- #
# Sync Theme #
# ---------- #
function synctheme {
	
	local SOURCETYPE; local SOURCESLUG; local SOURCEPATH; local THEMEPATH; local DOSYNC
	local THEME; THEME=$1;

	# TODO: sync theme for YML configs
	if [ -n "$YMLPATH" ]; then
		red "Error."; printf " Cannot sync theme for YML configs (yet.)"; echo ""; return
	fi

	# TODO: sync theme for alias
	if [ -n "$ALIAS" ]; then
		red "Error."; printf " Cannot sync theme for site aliases (yet.)"; echo ""; return
	fi

	# - read source config lines -
	while IFS= read -r -a SOURCE || [ -n "$SOURCE" ]; do

		# - ignore lines starting with # -
		if [ ! "${SOURCE:0:1}" == "#" ]; then

			# - expand source data -
			IFS=" " read -r -a DATA <<< "$SOURCE"
			SOURCETYPE=${DATA[0]}
			SOURCESLUG=${DATA[1]}
			SOURCEPATH=$(echo "${DATA[2]}" | tr -d '\r')

			if [ "$SOURCETYPE" == "theme" ]; then

				# TODO: handle .zip source files?
				# if [ -f "$SOURCEPATH" ]; then
				#	if [ ?is-zip? $SOURCEPATH ]; then
				# 		THEMEZIP="true"
				#		...extract zip to temp dir...
				#		SOURCEPATH=$TEMPDIR
				#	fi
				# fi

				if [ -d "$SOURCEPATH" ]; then

					# - reset do sync flag -
					DOSYNC=""

					# - maybe split source reference to get actual theme slug -
					# (useful for syncing development versions with same slug)
					ACTUALSLUG=""
					if [[ "$SOURCESLUG" == *":"* ]]; then
						IFS=":" read -r -a SLUGINFO <<< "$SOURCESLUG"
						SOURCESLUG=${SLUGINFO[0]}
						ACTUALSLUG=${SLUGINFO[1]}
						yellow "*"; white " Using source reference "; cyan "$SOURCESLUG"; white " for theme slug "; cyan "$ACTUALSLUG"; echo ""
					fi

					# - match theme slugs -
					if [ "$THEME" == "all" ] || [ "$THEME" == "$SOURCESLUG" ]; then 
						DOSYNC="true"
					else
						if [[ "$THEME" == *","* ]]; then
							IFS="," read -r -a THEMES <<< "$THEME"
							for THEMESLUG in "${THEMES[@]}"; do
								if [ "$THEMESLUG" == "$SOURCESLUG" ]; then DOSYNC="true"; fi
							done
						fi
					fi

					# - maybe set actual slug (if split) -
					if [ -n "$ACTUALSLUG" ]; then SOURCESLUG="$ACTUALSLUG"; fi

					# - maybe sync now -
					if [ "$DOSYNC" == "true" ]; then

						# - maybe create theme dir -
						THEMEPATH="$SITEPATH""wp-content/themes/""$SOURCESLUG""/"
						if [ ! -d "$THEMEPATH" ]; then
							sudo -u "$SITEUSER" mkdir "$THEMEPATH"
							chown "$SITEUSER" "$THEMEPATH"
						fi

						# - output syncing theme message -
						printf "Syncing Theme "; cyan "$SOURCESLUG"; printf " to site "; green "$SITENAME"; echo " "

						# - sync theme from source -							
						# TODO: maybe use rsync --backup option?
						sudo -u "$SITEUSER" rsync -av --delete --delay-updates "$SOURCEPATH" "$THEMEPATH"

						# - output theme sync info -							
						printf "Theme Path: "; cyan "$SOURCEPATH"; echo "";
						printf "Synced to: "; green "$THEMEPATH"; echo " "

						RESULT="success"
					fi

				else
					# - output invalid source directory message -
					red "Warning: "; printf "Invalid source directory, check "; white "wpx.conf"; printf " for "; yellow "$SOURCESLUG"; printf ". Skipping..."; echo " "
				fi

			fi
		fi
	done < "$CONFIG"

	if [ ! "$RESULT" == "success" ]; then
		# - output no matching theme message -
		red "Error!"; printf " No matching theme slug found, check "; white "wpx.conf"; printf " for "; yellow "$THEME"; echo "."
	fi
}

# ----------------------- #
# Sync and Activate Theme #
# ----------------------- #
function syncactivatetheme {

	local THEME; THEME=$1;

	# TODO: sync activate theme for YML configs
	if [ -n "$YMLPATH" ]; then
		red "Error."; printf " Cannot sync and activate theme for YML configs (yet.)"; echo ""; return
	fi

	# TODO: sync activate theme for alias
	if [ -n "$ALIAS" ]; then
		red "Error."; printf " Cannot sync and activate theme for site aliases (yet.)"; echo ""; return
	fi
		
	if [[ "$THEME" == *","* ]]; then
		# - output activate one theme only message -
		red "Failed!"; printf "You cannot activate multiple themes. Choose one!"; echo "";
	else
		# - output sync and activate theme message -
		yellow "****"; printf " Syncing and activating theme "; cyan "$THEME"; printf " on "; green "$SITENAME"; echo "..."
		
		# - sync theme -
		synctheme "$THEME";
		
		# - activate theme -
		if [ -n "$ACTUALSLUG" ]; then THEME="$ACTUALSLUG"; fi
		if [ "$RESULT" == "success" ]; then	
			activatetheme "$THEME"
		else
			red "Failed!"; printf "Plugin "; cyan "$THEME"; echo "not activated."
		fi
	fi
}

# ----------------------- #
# Sync Must Use Plugin(s) #
# ----------------------- #
function syncmuplugin {
	
	local SOURCETYPE; local SOURCESLUG; local SOURCEPATH; local PLUGINPATH; local DOSYNC
	local PLUGINS; PLUGINS=$1;

	# TODO: sync muse use plugin for YML configs
	if [ -n "$YMLPATH" ]; then
		red "Error."; printf " Cannot sync must-use plugins for YML configs (yet.)"; echo ""; return
	fi

	# TODO: sync must use plugin for alias
	if [ -n "$ALIAS" ]; then
		red "Error."; printf " Cannot sync must-use plugins for site aliases (yet.)"; echo ""; return
	fi

	# read file without requiring it to end in a new line
	# ref: https://stackoverflow.com/a/31398490/5240159
	while IFS= read -r -a SOURCE || [ -n "$SOURCE" ]; do

		# ignore lines starting with #
		if [ ! "${SOURCE:0:1}" == "#" ]; then

			# - expand source data -
			IFS=" " read -r -a DATA <<< "$SOURCE"
			SOURCETYPE=${DATA[0]}
			SOURCESLUG=${DATA[1]}
			SOURCEPATH=$(echo "${DATA[2]}" | tr -d '\r')

			if [ "$SOURCETYPE" == "muplugin" ]; then

				# TODO: handle .zip source files?
				# if [ -f $SOURCEPATH ]; then
				#	if [ ?is-zip? $SOURCEPATH ]; then
				# 		PLUGINZIP="true"
				#		...extract zip to temp dir...
				#		SOURCEPATH="$TEMPDIR"
				#	fi
				# fi

				if [ -d "$SOURCEPATH" ]; then

					# - reset do sync flag -
					DOSYNC="false"

					# - check slug match -
					if [ "$PLUGINS" == "all" ]; then
						DOSYNC="true"; fi
					if [ "$PLUGINS" == "$SOURCESLUG" ]; then
						DOSYNC="true"; fi
					if [[ "$PLUGINS" == *","* ]]; then
						IFS="," read -r -a PLUGINSLUGS <<< "$PLUGINS"
						for PLUGIN in "${PLUGINSLUGS[@]}"; do
							if [ "$PLUGIN" == "$SOURCESLUG" ]; then
								DOSYNC="true"; 
							fi
						done
					fi

					if [ "$DOSYNC" == "true" ]; then

						# - maybe create mu-plugin dir -
						PLUGINPATH=$SITEPATH"wp-content/mu-plugins/"
						if [ ! -d "$PLUGINPATH" ]; then
							sudo -u "$SITEUSER" mkdir "$PLUGINPATH"
							chown "$SITEUSER" "$PLUGINPATH"
						fi

						# - output syncing message -
						printf "Syncing Must-Use Plugin "; cyan "$SOURCESLUG"; printf " to site "; green "$SITENAME"; echo " "

						# - sync must use plugin -
						# Note: do not use --delete option here!!!
						# TODO: maybe use rsync with --backup option ?
						sudo -u "$SITEUSER" rsync -av --delay-updates "$SOURCEPATH" "$PLUGINPATH"

						# - output extra info -							
						printf "Must Use Plugin Path: "; cyan "$SOURCEPATH"; echo "";
						printf "Synced to: "; green "$PLUGINPATH"; echo " "

						RESULT="success"
					fi

				else
					# - output invalid source directory message -
					red "Warning: "; printf "Invalid source directory, check "; white "wpx.conf"; printf " for "; yellow "$SOURCESLUG"; printf ". Skipping..."; echo " "
				fi

			fi
		fi
	done < "$CONFIG"

	if [ ! "$RESULT" == "success" ]; then
		# - output no matching slug message -
		red "Error!"; printf " No matching must-use plugin slug found, check "; white "wpx.conf"; printf " for "; yellow "$PLUGINS"; echo "."
	fi
}

# -------------- #
# Sync Dropin(s) #
# -------------- #
# (files relative to source directory)
function syncdropin {
	
	local SOURCETYPE; local SOURCESLUG; local SOURCEPATH; local DOSYNC
	local FILE; FILE=$1

	# TODO: sync dropin for YML configs
	if [ -n "$YMLPATH" ]; then
		red "Error."; printf " Cannot sync dropins for YML configs (yet.)"; echo ""; return
	fi

	# TODO: sync dropin for site alias
	if [ -n "$ALIAS" ]; then
		red "Error."; printf " Cannot sync dropins for site aliases (yet.)"; echo ""; return
	fi

	# - read file without requiring it to end in a new line -
	# ref: https://stackoverflow.com/a/31398490/5240159
	while IFS= read -r -a SOURCE || [ -n "$SOURCE" ]; do

		# - ignore lines starting with # -
		if [ ! "${SOURCE:0:1}" == "#" ]; then

			# - expand source data -
			IFS=" " read -r -a DATA <<< "$SOURCE"
			SOURCETYPE=${DATA[0]}
			SOURCESLUG=${DATA[1]}
			SOURCEPATH=$(echo "${DATA[2]}" | tr -d '\r')

			if [ "$SOURCETYPE" == "dropin" ]; then

				# TODO: handle .zip source files?
				# if [ -f $SOURCEPATH ]; then
				#	if [ ?is-zip? $SOURCEPATH ]; then
				# 		PLUGINZIP="true"
				#		...extract zip to temp dir...
				#		SOURCEPATH=$TEMPDIR
				#	fi
				# fi

				if [ -d "$SOURCEPATH" ]; then

					# - reset do sync flag -
					DOSYNC="false"

					# - check slug match -
					if [ "$FILE" == "all" ]; then
						DOSYNC="true"; fi
					if [ "$FILE" == "$SOURCESLUG" ]; then
						DOSYNC="true"; fi
					if [[ "$FILE" == *","* ]]; then
						IFS="," read -r -a FILES <<< "$FILE"
						for FILE in "${FILES[@]}"; do
							if [ "$FILE" == "$SOURCESLUG" ]; then
								DOSYNC="true"; 
							fi
						done
					fi

					if [ "$DOSYNC" == "true" ]; then

						# - output syncing drop-in (base relative) files -
						printf "Syncing Drop-in Files "; cyan "$SOURCESLUG"; printf " to site "; green "$SITENAME"; echo " "

						# - sync base relative files -
						# note: do not use --delete option here!!!
						# TODO: maybe use rsync with --backup option ?
						sudo -u "$SITEUSER" rsync -av --delay-updates "$SOURCEPATH" "$SITEPATH"

						# - output extra info -
						printf "Source Base File Path: "; cyan "$SOURCEPATH"; echo "";
						printf "Synced to: "; green "$SITEPATH"; echo ""

						RESULT="success"
					fi

				else
					# - output invalid source directory message -
					red "Warning: "; printf "Invalid source directory, check "; white "wpx.conf"; printf " for "; yellow "$SOURCESLUG"; printf ". Skipping..."; echo " "
				fi

			fi
		fi
	done < "$CONFIG"

	if [ ! "$RESULT" == "success" ]; then
		# - output no slug match message -
		red "Error!"; printf " No matching base file slug found, check "; white "wpx.conf"; printf " for "; yellow "$FILES"; echo "."
	fi
}


# ------------------------- #
# === LANGUAGE COMMANDS === #
# ------------------------- #

# ---------------- #
# Install Language #
# ---------------- #
function installlanguage {

	local $LOCALE; LOCALE="$1"
	SUCCESS="Success: installed 1 of 1 languages"

	# - loop locale languages -
	IFS="," read -r -a LOCALES <<< "$LOCALE"
	for LOCALE in "${LOCALES[@]}"; do
	
		# - output installing language message -
		yellow "***"; printf " Installing language locale "; cyan "$LOCALE"; printf " on "; green "$SITENAME"; echo "..."
	
		# - set command and execute  -
		COMMAND="sudo -u ""$SITEUSER"" ""$WP"" language core install ""$LOCALE"
		OUTPUT=$($COMMAND)

		# - check result and maybe try again -
		checkresult "$OUTPUT" "$SUCCESS"
		if [ "$RESULT" == "failed" ]; then OUTPUT=$($COMMAND); fi

		echo "$OUTPUT"
	done
}

# ------------------ #
# Uninstall Language #
# ------------------ #
function uninstalllanguage {

	local $LOCALE; LOCALE="$1"
	SUCCESS="Success: Language uninstalled"	

	# - loop locale languages -
	IFS="," read -r -a LOCALES <<< "$LOCALE"
	for LOCALE in "${LOCALES[@]}"; do
	
		# - output installing language message -
		yellow "***"; printf " Uninstalling language locale "; cyan "$LOCALE"; printf " from "; green "$SITENAME"; echo "..."

		# - set command and execute -
		COMMAND="sudo -u ""$SITEUSER"" ""$WP"" language core uninstall ""$LOCALE"
		OUTPUT=$($COMMAND)
		
		# - check result and maybe try again -
		checkresult "$OUTPUT" "$SUCCESS"
		if [ "$RESULT" == "failed" ]; then OUTPUT=$($COMMAND); fi
		
		echo "$OUTPUT"
		
	done
}

# --------------- #
# Update Language #
# --------------- #
function updatelanguage {

	SUCCESS="Success: Translations are up to date"

	# - update languages -
	COMMAND="sudo -u ""$SITEUSER"" ""$WP"" language core update"
	OUTPUT=$($COMMAND)

	# - check result and maybe try again -
	checkresult "$OUTPUT" "$SUCCESS"
	if [ "$RESULT" == "failed" ]; then OUTPUT=$($COMMAND); fi

	echo "$OUTPUT"
}

# ----------------- #
# Activate Language #
# ----------------- #
function activatelanguage {

	local $LOCALE; LOCALE="$1"
	SUCCESS="Success: Language activated"

	# - output activating language message -
	yellow "***"; printf " Activating language locale "; cyan "$LOCALE"; printf " on "; green "$SITENAME"; echo "..."

	# - activate language -
	COMMAND="sudo -u ""$SITEUSER"" ""$WP"" site switch-language ""$LOCALE"
	OUTPUT=$($COMMAND)

	# - check result and maybe try again -
	checkresult "$OUTPUT" "$SUCCESS"
	if [ "$RESULT" == "failed" ]; then OUTPUT=$($COMMAND); fi

	echo "$OUTPUT"
}

# -----------------
# end all functions


# ------------------------------ #
# === COMMAND LINE ARGUMENTS === #
# ------------------------------ #

# [1.1] - check action argument -
if [ -z "$1" ]; then
	# - output valid commands message
	validcommands; exit 1
fi

# [1.2] - maybe set show configuration switch -
createarray "show" "config" "check" "config"; IN1=$(checkarray "$1")
createarray "show" "site" "check" "site"; IN2=$(checkarray "$1")
createarray "show" "source" "check" "source"; IN3=$(checkarray "$1")
if [ "$1" == "config" ] || [ "$IN1" == "1" ] || [ "$IN2" == "1" ] || [ "$IN3" == "1" ]; then 

	# - set done and show config values -
	DONE="true"; 
	if [ "$1" == "config" ] || [ "$IN1" == "1" ]; then SHOWCONFIG="true"; fi
	if [ "$IN2" == "1" ]; then SHOWCONFIG="sites"; fi
	if [ "$IN3" == "1" ]; then SHOWCONFIG="sources"; fi
	
	# - site table headings -
	if [ "$SHOWCONFIG" == "true" ] || [ "$SHOWCONFIG" == "sites" ]; then
		SITETABLE=""; 
		SITETABLE+=$(white "SLUG"); SITETABLE+="|"
		SITETABLE+=$(white "PATH"); SITETABLE+="|"
		SITETABLE+=$(white "USER"); SITETABLE+=$'\r\n'
	fi
	
	# - sources table headings -
	if [ "$SHOWCONFIG" == "true" ] || [ "$SHOWCONFIG" == "sources" ]; then
		SOURCETABLE=""
		SOURCETABLE+=$(white "TYPE"); SOURCETABLE+="|"
		SOURCETABLE+=$(white "SLUG"); SOURCETABLE+="|"
		SOURCETABLE+=$(white "PATH"); SOURCETABLE+=$'\r\n'
	fi
fi

# [2] - target site slugs -
if [ -z "$2" ]; then
	if [ -z "$SHOWCONFIG" ]; then
		red "Error!"; printf " Specify target site slug(s)... (or use "; yellow "all"; echo ")"; exit 1
	fi
else 
	# - extract comma separated arguments for $2 to sitename slugs -
	# ref: https://stackoverflow.com/questions/10586153/split-string-into-an-array-in-bash
	IFS="," read -r -a SITENAMES <<< "$2"

	# - loop sites to check for aliases -
	# (note: development only feature)
	I=0	
	for SITE in "${SITENAMES[@]}"; do
		# - maybe split to site and alias -
		if [[ "$SITE" == *"@"* ]]; then
			IFS="@" read -r -a SITEALIAS <<< "$SITENAMES"
			SITENAMES[$I]=${SITEALIAS[0]}
			ALIASES[$I]=${SITEALIAS[1]}
		fi
		((I++))
	done
fi

# [3.1] - plugin slugs for plugin actions -
if [[ "$1" == *"plugin"* ]]; then
	ARRAY=("updateallplugins" "update_all_plugins" "update-all-plugins"\
		"pluginsupdateall" "plugins_update_all" "plugins-update-all")
	INARRAY=$(checkarray "$1"); if [ ! "$INARRAY" == "1" ]; then
		if [ -z "$3" ]; then
			createarray "list" "plugin" "check" "plugin"; INARRAY=$(checkarray "$1")
			if [ "$INARRAY" == "1" ]; then
				# - auto-set to list all for list actions -
				SLUGS="all"
			else 	
				# - output specify plugin slugs message -
				red "Error!"; printf " You must specify plugin slug(s)"; echo "..."; exit 1
			fi
		else
			# - set to specified slugs -
			SLUGS="$3"
		fi
	fi
fi

# [3.2] - theme slugs for theme actions -
if [[ "$1" == *"theme"* ]]; then
	if [ -z "$3" ]; then
		createarray "list" "theme"; INARRAY=$(checkarray "$1")
		if [ "$INARRAY" == "1" ]; then
			# - auto-set to list all for list actions -
			printf "No theme specified, setting to "; yellow "all"; echo "..."
			SLUGS="all"
		else
		 	createarray "check" "theme"; INARRAY=$(checkarray "$1")
		 	if [ ! "$INARRAY" == "1" ]; then
				# - output specify theme slugs message -
				red "Error!"; printf " You must specify theme slug(s)"; echo "..."; exit 1
			fi
		fi	
	else
		# - set to specified slugs -
		SLUGS=$3
	fi
fi

# [3.3] - misc sync command slugs -
# - synccore : core slug -
# - syncmuplugin : muplugin slug -
# - syncdropin : dropin slug -
if [[ "$1" == *"sync"* ]]; then
	createarray "sync" "core" "sync" "dropin"; IN1=$(checkarray "$1")
	createarray "sync" "muplugin" "sync" "mustuseplugin"; IN2=$(checkarray "$1")
	createarray  "sync" "mu_plugin" "sync" "mu-plugin"; IN3=$(checkarray "$1")
	if [ "$IN1" == "1" ] || [ "$IN2" == "1" ] || [ "$IN3" == "1" ] ; then SLUGS="$3"; fi
fi

# [3.4] - arguments for core install / update -
# - installcore : version / locale -
# - updatecore : version -
createarray "install" "core" "update" "core"; INARRAY=$(checkarray "$1")
if [ "$INARRAY" == "1" ]; then
	if [ -n "$3" ]; then VERSION="$3"; fi
	if [ -n "$4" ]; then LOCALE="$4"; fi
fi

# [3.5] - arguments for language commands -
# note: locale not used for language updates
createarray "install" "language" "uninstall" "language"; IN1=$(checkarray "$1")
createarray "activate" "language"; IN2=$(checkarray "$1")
createarray "install" "locale" "uninstall" "locale"; IN3=$(checkarray "$1")
createarray "activate" "locale"; IN4=$(checkarray "$1")
if [ "$IN1" == "1" ] || [ "$IN2" == "1" ] || [ "$IN3" == "1" ] || [ "$IN4" == "1" ]; then
	if [ -n "$3" ]; then 
		LOCALE="$3"
		if [ "$DEBUG" == "true" ]; then echo "Locale: ""$LOCALE"; fi
	else 
		red "Error!"; printf " You must specify a language locale."; echo ""; exit 1
	fi
fi

# - debug output for slugs -
if [ "$DEBUG" == "true" ]; then echo "Slugs: ""$SLUGS"; fi


# -------------------------- #
# === LOOP SITE COMMANDS === #
# -------------------------- #

# - get current directory (to shell script path) -
# ref: https://stackoverflow.com/questions/59895/getting-the-source-directory-of-a-bash-script-from-within
DIR="$( cd "$( dirname "${BASH_SOURCE[0]}" )" && pwd )"

# - check and set wpx.conf path -
if [ -f "$DIR""/wpx.conf" ]; then
	CONFIG="$DIR""/wpx.conf"
else
	if [ -f "/root/.wp-cli/wpx.conf" ]; then
		CONFIG="/root/.wp-cli/wpx.conf"
	fi
fi
if [ -n "$CONFIG" ]; then
	# - output config found message -
	printf "Using WPX configuration file found at: "; cyan "$CONFIG"; echo ""
else 
	# - output no config file message -
	red "Error!"; printf " No "; yellow "wpx.conf"; printf " configuration file found!"; echo " Time to create one?"; exit 1
fi

# - loop all lines in config file - 
# (without requiring it to end in a new line)
# ref: https://stackoverflow.com/a/31398490/5240159
SITECOUNT=0; SOURCECOUNT=0; J=0; FOUNDSITES=()
while IFS= read -r -a LINE || [ -n "$LINE" ]; do

	# - ignore lines starting with # -
	if [ ! "${LINE:0:1}" == "#" ]; then

		# - expand config data -
		IFS=" " read -r -a DATA <<< $LINE
		TYPE=${DATA[0]}

		# - match only site lines -
		if [ "$TYPE" == "site" ]; then
		
			# - reset WP command -
			WP="wp"
		
			# - increment site count -
			((SITECOUNT++))
		
			# - get site data config -
			SITENAME=${DATA[1]}
			SITEPATH=${DATA[2]}
			SITEUSER=$(echo "${DATA[3]}" | tr -d '\r')
			SITEGROUP=""

			# - maybe get specified alias for site -
			I=0; ALIAS=""
			for SITE in "${SITENAMES[@]}"; do
				if [ -n "${ALIASES[$I]}" ]; then
					ALIAS="${ALIASES[$I]}"
					printf "Using Site Alias "; cyan "$ALIAS"; printf " for site "; green "$SITENAME"; echo "..."
				fi
				((I++))
			done

			# - maybe append site alias to WP command -
			if [ -n "$ALIAS" ]; then WP+=" @""$ALIAS"" "; fi

			# - maybe add to config output table -
			if [ "$SHOWCONFIG" == "true" ] || [ "$SHOWCONFIG" == "sites" ]; then
				SITETABLE+=$(white "$SITENAME"); SITETABLE+="|"
				SITETABLE+=$(white "$SITEPATH"); SITETABLE+="|"
				SITETABLE+=$(white "$SITEUSER"); SITETABLE+=$'\r\n'
			fi

			# - maybe split user into user:group -
			if [[ "$SITEUSER" == *":"* ]]; then
				IFS=":" read -r -a SITEINFO <<< "$SITEUSER"
				SITEUSER=${SITEINFO[0]}
				SITEGROUP=${SITEINFO[1]}
			fi

			# - maybe set site locking flag -
			if [ "${SITEPATH:0:1}" == "*" ]; then
				SITEPATH=${SITEPATH:1}
				SITELOCKING="true"
			else 
				SITELOCKING="false"
			fi

			# - maybe check specified .yml file for use as config -
			YMLPATH=""; EXT="${SITEPATH:(-4):4}"
			if [ "$EXT" == ".yml" ]; then
				EXT1="${SITEPATH:(-10):10}"; EXT2="${SITEPATH:(-16):16}"
				if [ "$EXT1" == "wp-cli.yml" ] || [ "$EXT2" == "wp-cli.local.yml" ]; then

					if [ -f "$SITEPATH" ]; then 
						if [ "$EXT1" == "wp-cli.yml" ]; then
							YMLPATH="$SITEPATH"
							SITEPATH="${SITEPATH:0:(-10)}"
						fi
						if [ "$EXT2" == "wp-cli.local.yml" ]; then
							YMLPATH="$SITEPATH"
							SITEPATH="${SITEPATH:0:(-16)}"
						fi
					else 
						# - output file not found message -
						red "Warning!"; printf " Site "; green "$SITENAME"; printf " config file not found. Path:"; cyan "$SITEPATH"; echo "";
					fi
				else
					# - output YML filename warning message -
					red "Warning!"; printf " Site "; green "$SITENAME"; printf " config YML file must be "; yellow "wp-cli.yml"; printf " or "; yellow "wp-cli.local.yml"; echo " only.";
				fi
			else
				# - check for config YML in standard path -
				# TODO: remote check for config YML in SSH path ?
				FILEPATH1="$SITEPATH""wp-cli.yml"; 
				FILEPATH2="$SITEPATH""wp-cli.local.yml"
				if [ -f "$FILEPATH1" ]; then YMLPATH="$FILEPATH1"; fi
				if [ -f "$FILEPATH2" ]; then YMLPATH="$FILEPATH2"; fi
			fi

			# - if alias specified, check if using YML config -
			SKIP="";
			if [ -n "$ALIAS" ] && [ -z "$YMLPATH" ]; then
				# - output need YML config message and set to skip -
				red "Error!"; printf " Site "; green "$SITENAME"; printf " Alias "; cyan "$ALIAS"; echo ": An Alias can only be used via a config YML file.";
				SKIP="true"; 
			fi

			# - check for site path directory -
			# TODO: handle for SSH ?
			if [ -z "$SKIP" ] && [ -d "$SITEPATH" ]; then

				# - switch to site path -
				if [ -n "$SITEPATH" ]; then 
					# TODO: handle for SSH ?
					cd "$SITEPATH"
				fi

				# - reset do flag -
				DO="false"

				# - check site slug match -
				if [ "$2" == "all" ]; then
					DO="true"; FOUND="true"; FOUNDSITES[0]="all";
				fi
				if [ "$2" == "$SITENAME" ]; then
					DO="true"; FOUND="true"; FOUNDSITES[0]="$SITE";
				fi
				if [[ "$2" == *","* ]]; then
					for SITE in "${SITENAMES[@]}"; do
						if [ "$SITE" == "$SITENAME" ]; then
							DO="true"; FOUND="true";
							FOUNDSITES[$J]="$SITE"; ((J++))
						fi
					done
				fi

				# - check for matching command -
				if [ "$DO" == "true" ]; then
				
					# ------------- #
					# CORE COMMANDS #
					# ------------- #

					# - run wp --debug --info -
					if [ "$1" == "debug" ]; then wpdebug; DONE="true"; fi

					# - check version for core(s) -	
					createarray "check" "version" "check" "core"; INARRAY=$(checkarray "$1")
					if [ "$INARRAY" == "1" ]; then checkversion; DONE="true"; fi
						
					# - verify checksums for core(s) -
					createarray "verify" "core" "verify" "checksum"; INARRAY=$(checkarray "$1")
					if [ "$INARRAY" == "1" ]; then verifycore; DONE="true"; fi

					# - update core(s) -
					createarray "update" "core"; INARRAY=$(checkarray "$1")
					if [ "$INARRAY" == "1" ]; then updatecore "$VERSION"; DONE="true"; fi

					# - install core(s) -
					createarray "install" "core"; INARRAY=$(checkarray "$1")
					if [ "$INARRAY" == "1" ]; then installcore "$VERSION" "$LOCALE"; DONE="true"; fi

					# - reinstall core(s) -
					createarray "reinstall" "core"; INARRAY=$(checkarray "$1")
					if [ "$INARRAY" == "1" ]; then reinstallcore; DONE="true"; fi		
					
					# - lock core(s) -
					createarray "lock" "core"; INARRAY=$(checkarray "$1")
					if [ "$INARRAY" == "1" ]; then lockcore; DONE="true"; fi

					# - unlock core(s) -						
					createarray "unlock" "core"; INARRAY=$(checkarray "$1")
					if [ "$INARRAY" == "1" ]; then unlockcore; DONE="true"; fi

					# - check lock on core(s) -
					createarray "check" "lock" "check" "corelock"; INARRAY=$(checkarray "$1")
					if [ "$INARRAY" == "1" ]; then checkcorelock; DONE="true"; fi
						
					# - check owner/group permission(s) -
					createarray "check" "owner" "check" "permission"; IN1=$(checkarray "$1")
					createarray "check" "perm"; IN2=$(checkarray "$1")
					if [ "$IN1" == "1" ] || [ "$IN2" == "1" ]; then
						checkowners; DONE="true"; fi

					# - fix owner/group permission(s) -	
					createarray "fix" "owner" "fix" "permission"; IN1=$(checkarray "$1")
					createarray "fix" "perm"; IN2=$(checkarray "$1")
					if [ "$IN1" == "1" ] || [ "$IN2" == "1" ]; then
						fixowners; DONE="true"; fi

					# --------------- #
					# PLUGIN COMMANDS #
					# --------------- #

					# - check/list plugin(s) -
					createarray "list" "plugin" "check" "plugin"; INARRAY=$(checkarray "$1")
					if [ "$INARRAY" == "1" ]; then listplugins "$SLUGS"; DONE="true"; fi

					# - install plugin(s) -	
					createarray "install" "plugin"; INARRAY=$(checkarray "$1")
					if [ "$INARRAY" == "1" ]; then installplugin "$SLUGS"; DONE="true"; fi

					# - reinstall plugin(s) -
					createarray "reinstall" "plugin"; INARRAY=$(checkarray "$1")
					if [ "$INARRAY" == "1" ]; then reinstallplugin "$SLUGS"; DONE="true"; fi

					# - install and activate plugin(s) -
					createarray "installactivate" "plugin"; IN1=$(checkarray "$1")
					createarray "install_activate" "plugin" "install-activate" "plugin"; IN2=$(checkarray "$1")
					if [ "$IN1" == "1" ] || [ "$IN2" == "1" ]; then
						installactivateplugin "$SLUGS"; DONE="true"; fi

					# - activate plugin(s) -
					createarray "activate" "plugin"; INARRAY=$(checkarray "$1")
					if [ "$INARRAY" == "1" ]; then activateplugin "$SLUGS"; DONE="true"; fi

					# - deactivate plugin(s) -
					createarray "deactivate" "plugin"; INARRAY=$(checkarray "$1")
					if [ "$INARRAY" == "1" ]; then deactivateplugin "$SLUGS"; DONE="true"; fi
										
					# - delete plugin(s) -
					createarray "delete" "plugin"; INARRAY=$(checkarray "$1")
					if [ "$INARRAY" == "1" ]; then deleteplugin "$SLUGS"; DONE="true"; fi
					
					# - uninstall plugin(s) (deactivate and delete) -
					createarray "uninstall" "plugin" "deletedeactivate" "plugin"; IN1=$(checkarray "$1")
					createarray "deactivate_delete" "plugin" "deactivate-delete" "plugin"; IN2=$(checkarray "$1")
					if [ "$IN1" == "1" ] || [ "$IN2" == "1" ]; then
						uninstallplugin "$SLUGS"; DONE="true"; fi

					# - update plugin(s) -
					createarray "update" "plugin"; INARRAY=$(checkarray "$1")
					if [ "$INARRAY" == "1" ]; then updateplugin "$SLUGS"; DONE="true"; fi

					# - update all plugins -
					ARRAY=("updateallplugins" "update_all_plugins" "update-all-plugins"); IN1=$(checkarray "$1")
					ARRAY=("pluginsupdateall" "plugins_update_all" "plugins-update-all"); IN2=$(checkarray "$1")
					if [ "$IN1" == "1" ] || [ "$IN2" == "1" ]; then
						updateplugin "all"; DONE="true"; fi

					# -------------- #
					# THEME COMMANDS # 
					# -------------- #

					# - list theme(s) -
					createarray "list" "theme"; INARRAY=$(checkarray "$1")
					if [ "$INARRAY" == "1" ]; then listthemes "$SLUGS"; DONE="true"; fi
					
					createarray "check" "theme"; INARRAY=$(checkarray "$1")
					if [ "$INARRAY" == "1" ]; then checktheme; DONE="true"; fi
					
					# - activate theme (singular only) -
					createarray "activate" "theme"; INARRAY=$(checkarray "$1")
					if [ "$INARRAY" == "1" ]; then activatetheme "$SLUGS"; DONE="true"; fi
					
					# - install theme(s) -
					createarray "install" "theme"; INARRAY=$(checkarray "$1")
					if [ "$INARRAY" == "1" ]; then installtheme "$SLUGS"; DONE="true"; fi
					
					# - reinstall theme(s)
					createarray "reinstall" "theme"; INARRAY=$(checkarray "$1")
					if [ "$INARRAY" == "1" ]; then reinstalltheme "$SLUGS"; DONE="true"; fi
					
					# - update theme(s) -
					createarray "update" "theme"; INARRAY=$(checkarray "$1")
					if [ "$INARRAY" == "1" ]; then updatetheme "$SLUGS"; DONE="true"; fi
					
					# - update all themes -
					ARRAY=("updateallthemes" "update_all_themes" "update-all-themes"); IN1=$(checkarray "$1")
					ARRAY=("themesupdateall" "themes_update_all" "themes-update-all"); IN2=$(checkarray "$1")
					if [ "$IN1" == "1" ] || [ "$IN2" == "1" ]; then
						updatetheme "all"; DONE="true"; fi
	
					# ------------- #
					# SYNC COMMANDS #
					# ------------- #

					# - sync core(s) -
					createarray "sync" "core"; INARRAY=$(checkarray "$1")
					if [ "$INARRAY" == "1" ]; then synccore "$SLUGS"; DONE="true"; fi
					
					# - sync plugin(s) -
					createarray "sync" "plugin"; INARRAY=$(checkarray "$1")
					if [ "$INARRAY" == "1" ]; then syncplugin "$SLUGS"; DONE="true"; fi
						
					# - sync and activate plugin(s) -
					createarray "syncactivate" "plugin" "sync" "activateplugin"; IN1=$(checkarray "$1")
					createarray "sync_activate" "plugin" "sync-activate" "plugin"; IN2=$(checkarray "$1")
					if [ "$IN1" == "1" ] || [ "$IN2" == "1" ]; then 
						syncactivateplugin "$SLUGS"; DONE="true"; fi
						
					# - sync theme(s) -
					createarray "sync" "theme"; INARRAY=$(checkarray "$1")
					if [ "$INARRAY" == "1" ]; then synctheme "$SLUGS"; DONE="true"; fi
						
					# - sync and activate theme (singular only) -
					createarray "syncactivate" "theme" "sync" "activatetheme"; IN1=$(checkarray "$1")
					createarray "sync_activate" "theme" "sync-activate" "theme"; IN2=$(checkarray "$1")
					if [ "$IN1" == "1" ] || [ "$IN2" == "1" ]; then 
						syncactivatetheme "$SLUGS"; DONE="true"; fi
						
					# - sync must-use plugin(s) -
					createarray "sync" "muplugin" "sync" "mu-plugins"; IN1=$(checkarray "$1")
					createarray "sync" "mu_plugins"; IN2=$(checkarray "$1")
					if [ "$IN1" == "1" ] || [ "$IN2" == "1" ]; then
						syncmuplugin "$SLUGS"; DONE="true"; fi
						
					# - sync dropin file(s) -
					createarray "sync" "dropin"; INARRAY=$(checkarray "$1")
					checkarray "$1"; if [ "$INARRAY" == "1" ]; then syncdropin "$SLUGS"; DONE="true"; fi

					# ----------------- #
					# LANGUAGE COMMANDS #
					# ----------------- #
					
					# - install language locale pack(s) -
					createarray "install" "language" "install" "locale"; INARRAY=$(checkarray "$1")
					if [ "$INARRAY" == "1" ]; then installlanguage "$LOCALE"; DONE="true"; fi
						
					# - uninstall language locale pack(s) -
					createarray "uninstall" "language" "uninstall" "locale"; INARRAY=$(checkarray "$1")
					if [ "$INARRAY" == "1" ]; then uninstalllanguage "$LOCALE"; DONE="true"; fi
						
					# - activate language locale pack (singular only) -
					createarray "activate" "language" "activate" "locale"; INARRAY=$(checkarray "$1")
					if [ "$INARRAY" == "1" ]; then activatelanguage "$LOCALE"; DONE="true"; fi
						
					# - update language locale pack(s) -
					createarray "update" "language" "update" "locale"; INARRAY=$(checkarray "$1")
					if [ "$INARRAY" == "1" ]; then updatelanguage; DONE="true"; fi

				fi
				
				# - switch back to working directory -
				if [ -n "$SITEPATH" ]; then 
					# TODO: handle for SSH ?
					cd "$CWD"
				fi

			else
				# - if not already checked and skipped -
				if [ ! "$SKIP" == "true" ]; then
					# - output invalid site path message -
					red "Warning!"; printf " Invalid path for "; green "$SITENAME"; 
					if [ -n "$ALIAS" ]; then printf "@"; yellow "$ALIAS"; fi
					printf ": "; yellow "$SITEPATH"; printf ". Skipping"; echo "..."
				fi
			fi
		else
			# - for non-site config display -
			if [ "$SHOWCONFIG" == "true" ] || [ "$SHOWCONFIG" == "sources" ]; then
				
				# - increment source count -
				((SOURCECOUNT++))
				
				# - set type / slug / path columns -
				SOURCETABLE+=$(white "${DATA[0]}"); SOURCETABLE+="|"
				SOURCETABLE+=$(white "${DATA[1]}"); SOURCETABLE+="|"
				SOURCETABLE+=$(white "${DATA[2]}"); SOURCETABLE+=$'\r\n'
			fi
		fi
	fi
done < "$CONFIG"

# - maybe output show config tables -
if [ -n "$SHOWCONFIG" ]; then

	# - sites table -
	if [ "$SITECOUNT" -gt 0 ] && [ ! "$SHOWCONFIG" == "sources" ]; then
		cyan "SITES"; echo ""
		OUTPUT=$(column -t -s "|" <<< "$SITETABLE")
		echo "$OUTPUT"
	fi

	# - maybe line break between tables -
	if [ "$SHOWCONFIG" == "true" ] && [ "$SITECOUNT" -gt 0 ] && [ "$SOURCECOUNT" -gt 0 ]; then echo ""; fi
	
	# - sources table -
	if [ "$SOURCECOUNT" -gt 0 ] && [ ! "$SHOWCONFIG" == "sites" ]; then
		cyan "SOURCES"; echo ""
		OUTPUT=$(column -t -s "|" <<< "$SOURCETABLE")
		echo "$OUTPUT"
	fi
	exit 0
fi

# - output no site slug match message -
if [ -z "$FOUND" ]; then
	red "Error!"; printf " No site match found for "; yellow "$2"; red " in "; white "wpx.conf"; echo "!"
fi

# - output invalid command message -
if [ -z "$DONE" ]; then	
	red "Error!"; printf " Command action "; yellow "$1"; printf " not found!"; echo ""
	validcommands; exit 1
fi

# - check for site(s) specified but not found -
for SITE in "${SITENAMES[@]}"; do
	FOUND=""
	for FOUNDSITE in "${FOUNDSITES[@]}"; do
		if [ "$SITE" == "$FOUNDSITE" ]; then FOUND="true"; fi
	done
	if [ ! "$FOUND" == "true" ]; then
		red "Warning!"; printf " No matching site config found for slug "; cyan "$SITE"; echo ""
	fi
done


# -----------------
# === CHANGELOG ===
# -----------------

# = 1.0.3 =
# - added plugin list filtering capability
# - group active plugins/theme at top of lists
# - output extra info for core version check
# - check for core updates with core version check
# - fix to plugin update command string

# = 1.0.2 =
# - set command string once (for DRY command reattempt usage)
# - check commands against array list of possibile combinations
# - change directory to site path instead of using wp --path=
# - changed updateallplugins to use updateplugins all
# - expand source data lines with read instead of ()
# - allow splitting of theme/plugin source slugs (for dev versions)
# - added show config command (output column formatted wpx.conf)
# - added site@alias argument splitting (needs wp-cli.yml config)
# - added setting wp-cli.yml path via wpx.conf (prototype)
# - added reading of wp-cli.yml with aliases fix (prototype)
# - added patch core updates by setting version argument to patch

# = 1.0.1 =
# - use single wpx.conf config instead of sources.conf and sites.conf
# - added code comment lines to all functions and sections
# - added column formatting for plugin and theme list output
# - added core language commands (install/uninstall/activate/update)
# - removed duplicate code for processing multiple/singular sources
# - quoted all variables (and other minor fixes) to pass ShellCheck
# - use exact array check function for actions instead of quick matching
# - use exact slug match for theme column in theme check function
# - allow minor core updates by setting version argument to minor

# = 1.0.0 =
# - added syncmuplugin and syncdropin commands
